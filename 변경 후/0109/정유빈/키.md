<h1> 키 (KEY) </h1>

- 특정 튜플을 식별할 때 사용하는 속성 혹은 속성의 집합

- 키가 되는 속성(혹은 속성의 집합)은 반드시 달라서 튜플들을 구별할 수 있어야 함

- 키는 릴레이션 간의 관계를 맺는데 사용됨

- 한 릴레이셔에서 중복되는 튜플들은 존재할 수 없습니다. <br />
  그러므로 각각의 튜플에 포함된 속성들 중 허느 하나(혹은 하나 이상)은 값이 달라져야 하고, 각각의 튜플을 식별하는 역할을 키(Key)가 담당합니다. <br />
  일반적으로 키는 단일 속성으로 지정하지만 아래의 그림처럼 그렇지 못한 경우에는 두 개 이상의 속성을 묶어 키로 사용한다. <br />
  아래의 릴레이션에서는 (고객번호, 도서번호)나 (고객번호, 주문일자)와 같은 집합을 키로 사용할 수 있습니다.
  
 ![image](https://user-images.githubusercontent.com/62228401/211226943-1fa6f5a9-ab37-4d7f-a841-aac115755816.png)

<h1> 슈퍼 키 </h1>

  - 튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합
  - 튜플을 식별할 수 있으면 모두 슈퍼키가 될 수 있음
  - 아래와 같은 고객 릴레이션의 경우에는 이름이나 주소(가족 관계)는 동일한 값이 올 수 있고, 핸드폰의 경우에는 핸드폰이 없는 사람도 있을 수가 있으므로 고객번호 또는 주민번호가 슈퍼키가 될 수 있습니다.
  - 그러므로 고객 릴레이션은 고객 번호 또는 주민번호를 포함한 모든 속성의 집합이 슈퍼키가 될 수 있습니다.
  - (주민번호), (주민번호, 이름), (고객번호, 이름, 주민번호, 주소, 핸드폰 )등 여러 개가 슈퍼키가 될 수 있다.

  ![image](https://user-images.githubusercontent.com/62228401/211227091-164a07d1-4e00-4f7a-853d-eb2a728f99c3.png)

<h1> 후보 키 </h1>

  - 튜플을 유일하게 식별할 수 있는 속성의 최소 집합
  
  - 주문 릴레이션에서 단일 속성으로는 튜플을 유일하게 식별하는 것이 불가능하므로 2개의 속서을 합한(고객번호, 도서번호)가 후보키가 되며 이렇게 2개 이상의 속성으로 이루어진 키를 복합키(Composite Key)라고 한다.
  
    ![image](https://user-images.githubusercontent.com/62228401/211227163-9ce7eec3-243b-4a1a-a440-e038c90df261.png)
    
    
 <h1> 기본 키 </h1>
 
  - 여러 후보키 중 하나의 선정하여 대표로 삼는 키

  - 후보키가 하나 뿐이라면 그 후보키를 기본키(Primary Key)로 사용하면 되고, 후보키가 여러 개라면 릴레이션의 특성을 반영하여 하나를 선택한다.

   - 아래의 도서 릴레이션에서는 도서 번호 또는 도서 이름이 후보키가 되고, 두 속성 중 하나의 속성을 기본키로 선정하면 된다.(도서 이름이 중복되지 않는다고 가정)

   - 도서 릴레이션의 경우에는 도서(<u>도서번호</u>, 도서이름, 출판사, 가격)처럼 표시하면 된다.

  ![image](https://user-images.githubusercontent.com/62228401/211227272-c3fada54-e203-4861-bd58-8312a3d18020.png)


<h1> 기본 키 설정 시 고려 사항 </h1>

- 릴레이션 내 튜플을 식별할 수 있는 고유한 값을 가져야 함
- NULL값은 허용하지 않음
- 키 값의 변동이 일어나지 않아야 함
- 최대한 적은 수의 속성을 가진 것이어야 함
- 향후 키를 사용하는데 있어서 문제 발생 소지가 없어야 함

- 기본키가 NULL값이 되면, 다른 튜플과 식별할 수 없으므로 안 된다. 키 값의 변동이 일어나지 않아야 하는 이유는 기본키가 변경되면 릴레이션 내에서 기본키를 제외하고 나머지 속성이 같았던 튜플이 기본키를 바꿈으로 중복될 수 있기 때문이다.


<h1> 대체 키 </h1>

- 기본키로 선정되지 않은 후보 키
- 대체키(Alternate Key)는 기본키로 선정되지 않은 후보키로 고객 릴레이션에서 고객번호와 주민 번호 중 고객번호를 기본키로 정하면, 주민번호가 대체키가 된다.

<h1> 외래 키 </h1>

- 다른 릴레이션의 기본 키를 참조하는 속성

- 키는 관계를 맺는데 활용될 수 있다고 하는데, 외래키(Foreign Key)가 바로 그런 경우이다.
- 주문 릴레이션에서 고객 릴레이션의 기본키인 고객 번호와 도서 릴레이션의 기본키인 도서번호를 참조하여 쓰는데 주문릴레이션에서는 고객 번호와 도서번호가 외래키가 되고, 주문번호가 기본 키(Primary Key)가 된다.

  ![image](https://user-images.githubusercontent.com/62228401/211227548-eec298c1-a625-43ec-9f1f-166077f1ceb5.png)

- 외래 키를 사용할 때 릴레이션과 참조되는 릴레이션이 다를 필요는 없다.
- 즉, 한 릴레이션에서 자기 자신의 기본 키를 외래키로 가질 수가 있다.
- 아래의 그림에서는 선수 번호라는 기본키를 자기 자신의 릴레이션에서 멘토 번호로 참조하고 있다.
- 멘토 릴레이션에서는 이미 선수번호라는 기본키가 존재하기 때문에 외래키는 NULL값이 되어도 상관없다.

  ![image](https://user-images.githubusercontent.com/62228401/211227622-da1a21b9-1cc0-418a-97e1-f7c0c5954ce9.png)

  ![image](https://user-images.githubusercontent.com/62228401/211227629-29ba67a4-e7c4-4627-b885-c53d996ae05f.png)
  
  <h1> 무결성 제약조건 </h1>
  
  - 데이터 무결성 제약조건
    - 도메인 제약(Domain Constraint)라고 하며, 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건
    - SQL문에서 데이터 형식(Type), 널(Null, Not Null), 기본 값(Default), 체크(Check) 등을 사용하며 지정할 수 있다.
    - 예를 들어 VARCHAR형으로 선언된 Name이라는 변수에는 정수형 Integer 값이 올 수 없는 경우를 의미한다.

  - 개체 무결성 제약 조건
    - 기본 키 제약(Primary Key Constraint)라고 함
    - 릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙 즉, 기본키는 NULL값을 가져서는 안 되며 릴레이션 내에 오직 하나의 값만 가져야 한다는 조건
    - 기본키는 릴레이션 내에서 튜플들을 구별할 수 있게 해주는 속성이므로, 자연스럽게 개체 무결성 제약조건이 등장하였음

  - 참조 무결성 제약 조건
    - 외래키 제약(Foreign Key Constraint)라고 함
    - 릴레이션 간의 참조관계를 선언하는 제약 조건
    - 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션 값이 변경될 때 부모 리렐이션의 제약을 받는다는 의미

    ![image](https://user-images.githubusercontent.com/62228401/211228555-e5c5949f-d146-4c7a-b26a-15a1d1559f8a.png)

<h3> 개체 무결성 제약 조건 </h3>

- 삽입
  - 기본키 값이 같으면 삽입이 금지됨

- 수정
  - 기본키 값이 같거나 NULL로도 수정이 금지됨

- 삭제
  - 특별한 확인이 필요하지 않으며 즉시 수행함

아래의 그림과 같이 학번을 기본키로 갖는 릴레이션에서 이미 학번 501을 가진 학생이 존재할 때 중복된 학번 501을 가진 학생이 존재할 때 중복된 학번 501을 가진 학생을 삽입하려고 하거나 501로 다른 학생의 학번을 수정하려고 하거나, 학번이 NULL인 튜플을 삽입하려고 하는 경우 삽입이 거부됨</br>
그에 반에 삭제 연산은 기본키의 중복 또는 NULL의 염려가 없으므로 즉시 수행됨

![image](https://user-images.githubusercontent.com/62228401/211228704-d329a70e-27b3-4b88-a91b-d27c8e012977.png)

<h1> 참조 무결성 제약조건 </h1>

- 부모 릴레이션에 삽입 : 정상적으로 진행됨
- 자식 릴레이션에 삽입 : 참조받는 테이블에 외래키 값이 없으므로 삽입 금지
- 부모 릴레이션의 삭제 : 참조하는 테이블을 같이 삭제할 수 있어서 금지하거나 추가 작업이 필요
- 자식 릴레이션의 삭제 : 바로 삭제 가능함
- 수정 : 삭제와 삽입의 연속 수행으로 각 삭제와 삽입의 제약을 고려하여 진행됨

예를 들어 아래의 릴레이션에서 부모에 3001의 학과코드를 가진 학과를 추가하는 것은 문제가 없지만, 자식 릴레이션에 부모 릴레이션에 존재하지 않는 3001의 학과코드를 삽입하려고 하는 경우에는 문제가 발생한다. </br>
부모 릴레이션에서 삭제를 진행하는 경우에는 해당 키를 다른 릴레이션에서 사용하고 있을 수 있으므로 삭제에 제한이 걸리지만 자식 릴레이션은 바로 삭제를 할 수 있다. </br>
수정 연산은 부모 릴레이션의 수정이 일어날 경우 삭제 옵션에 따라 처리된 후 문제가 없으면 다시 삽입 제약조건에 따라 처리된다.

![image](https://user-images.githubusercontent.com/62228401/211228956-7bcb659b-3171-4070-8863-7f3920785b20.png)

