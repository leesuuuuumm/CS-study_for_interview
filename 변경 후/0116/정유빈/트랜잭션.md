<h1> 트랜잭션 </h1>

- 데이터베이스를 변경하는 한꺼번에 모두 수행되어야 할 논리적 단위

<h1> 트랜잭션 특징 </h3>

- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위
- 하나의 트랜잭션은 Commit되거나 Rollback된다.

<h1> 트랜잭션의 성질 </h1>

<h3> 원자성 - Atomicity </h3> 

- 트랜잭션의 연산은 데이터베이스에 모두 반영되거나 전혀 반영되지 않아야 한다.
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
- 만약 긴 트랜잭션 범위 내에서 대부분의 로직이 성공적으로 수행되었는데, 마지막에 문제가 생겨서 롤백이 된다고 생각해보자. 문제가 발생하지 않은 영역까지 반복적으로 수행해야 하는 건, 손해이기 때문에 성공적인 지점까지는 savePoint를 설정할 수 있다.

<h5> savePoint </h5>

- 트랜잭션 내부에서 사용자가 지정할 수 있는 세부 작업 단위로, 아래 그림처럼 특정 지점에 savePoint라고 설정 후 'Rollback to savePoint1'을 통해 해당 지점으로 롤백 할 수 있다.
- 기억해야 할 점은, 아래 그림에서 SP1으로 롤백한 뒤에는 미래 시점인 SP2의 savePoint는 삭제 된다는 점이다.

![image](https://user-images.githubusercontent.com/62228401/212689126-14a435b3-d108-4f33-82c8-ea8560aecb39.png)

<h3> 일관성 - Consistency </h3>

- 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- 트랜잭션 전 후의 데이터베이스의 상태가 Correct State라고 하는데, 도메인의 유효 범위 등의 무결성 제약조건을 위배하지 않는 상태를 말한다.
- 예시로, 도메인 무결성 제약 조건, 개체 무결성 제약 조건, 참조 무결성 제약 조건을 지켜야 한다.
- 무결성이란, 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것을 말한다.
- 도메인 무결성 제약 조건이란, 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건이다.
- 개체 무결성 제약 조건이란, 기본키는 NULL값을 가져서는 안 되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건이다.
- 참조 무결성 제약 조건이란, 릴레이션 간의 참조 관계를 선언하는 제약 조건으로, 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다는 것이다.

<h3> 고립성 - Isolation </h3> 

- 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하지 않아야 한다.
- 트랜잭션은 기본적으로 원자성, 일관성, 지속성을 보장해주지만, 격리성의 경우 완전히 보장하려면 각각의 트랜잭션을 순서대로 처리해야 한다.
- 이는 동시성 처리 성능을 매우 나쁘게 하기 때문에, 격리성의 수준을 여러 단계로 나눌 수 있다.

  <h4> READ UNCOMMITED </h4>
    
    - 상대방이 커밋하지 않은 데이터를 읽을 수 있다.
    - 예를 들어, 사용자 A가 트랜잭션 내에서 데이터를 수정하고 있는데, 사용자 B가 그 데이터를 조회할 수 있다.
    - 커밋되지 않은 데이터를 조회하는 걸 Dirty Read라고 한다.
    - 사용자 B가 데이터를 사용하는 도중에 사용자 A가 데이터를 롤백시키면 데이터 정합성이 깨질 수 있다.

  <h4> READ COMMITED </h4>
  
  - 상대방이 커밋한 데이터만 조회할 수 있다. 따라서, Dirty Read는 발생하지 않는다.
  - 하지만, NON-REPEATABLE READ가 발생할 수 있다.
  - 사용자 A가 커밋한 데이터를 사용자 B가 트랜잭션 내에서 조회하고 있는데 이후에 사용자 A가 데이터를 수정 후 다시 커밋한다면 사용자 B는 같은 트랜잭션 내에서 다른 데이터를 조회하게 되는 것이다.
  
  <h4> REPEATABLE READ </h4>
  
  - 한 번 조회한 데이터는 트랜잭션 내에서 다시 조회해도 같은 데이터가 나오는 것이 보장된다.
  - 하지만 PHANTOM-READ가 발생할 수 있다.
  - 예를 들어, 사용자 A가 트랜잭션 내에서 20살 이하의 회원 리스트를 조회했을 때, 중간에 사용자 B가 회원을 20살 이하 회원을 한 명 추가한다면, 다시 리스트를 조회했을 때 나오는 결과가 달라질 수 있다.
  - 이처럼 결과 집합이 달라지는 것을 PANTHOM READ라 한다.

  <h4> SERIALABLE </h4>
  
  - 가장 엄격한 수준의 격리성이지만 동시성 처리에는 매우 약하다.
  - 데이터베이스들은 보통 동시성 처리가 중요하기 대문에, READ COMMITED 수준의 격리성을 사용한다.

<h3> 지속성 - Durabilty </h3>

- 트랜잭션의 성공 결과 값은 장애 발생 후에도 변함없이 보관되어야 한다는 것으로, 트랜잭션이 정상적으로 완료(Commit)된 경우에는 버퍼의 내용을 하드디스크(데이터베이스)에 확실히 기록하여야 하며, 부분 완료(Partial Commit)된 경우에는 작업을 취소하여야 합니다.
- 즉, 정상적으로 완료 혹은 부분 완료된 데이터는 DBMS가 책임지고 데이터베이스에 기록하는 성질이 지속성이며 영속성이라고 합니다.


<h1> 트랜잭션과 DBMS </h1>

- DBMS는 원자성을 유지하기 위해 회복(복구) 관리자 프로그램을 작동시킴
  - 일부만 진행된 트랜잭션을 취소시킴
- DBMS는 일관성을 유지하기 위해 동시성 제어 알고리즘과 무결성 제약 조건을 활용함
- DBMS는 고립성을 유지하기 위해 동시성 제어 알고리즘을 작동시킴
  - 동시에 접근하지 않도록 동시성 제어(Locking)을 활용하여 이를 해결
  - 파일 시스템과 같은 경우처럼 값이 덮어 씌워지는(Overwrite)의 경우 일관성이 무너질 수 있고 그러한 경우 고립성에 위배되는 경우이므로 Locking을 하여 이를 만족시킨다.
- DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 작동시킴

![image](https://user-images.githubusercontent.com/62228401/212687606-602359c3-d04f-4d48-bb61-f161318f6547.png)


<h1> 트랜잭션 상태 </h1>

- 활동(Active) : 트랜잭션이 현재 실행 중인 상태
- 실패(Failed) : 트랜잭션이 실행되다가 오류가 발생해서 중단된 상태
- 철회(Aborted) : 트랜잭션이 비정상 종료되어 Rollback이 수행된 상태
- 부분완료(Partially Commited) : 트랜잭션 연산이 마지막까지 실행되고 Commit되기 직전 상태
- 완료(Commtited) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태
