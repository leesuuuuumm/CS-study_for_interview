<h1> 인덱스 </h1>

- DB 내 저장된 데이터의 "주소"를 갖는 것

![image](https://user-images.githubusercontent.com/62228401/213964304-b0b60ca6-0265-40f1-a3a2-63900c94f4b4.png)
- 위 그림처럼 테이블 내의 1개의 컬럼, 혹은 여러 개의 칼럼을 Key로 삼고, Key에 해당하는 레코드의 물리적 주소 값이 저장되어 이씅ㅁ

- DB 데이터 조회 성능 향상을 위해 사용

<h1> 인덱스 장점 </h1>

1. 조건 검색 WHERE절의 효율성
    - 위 그림처럼, 인덱스 테이블은 정렬되어 저장되어 있기 때문에 해당 조건(WHERE)절에 맞는 데이터를 빠르게 찾아낼 수 있음

2. 정렬 ORDER BY절의 효율성
    - 부하가 굉장히 많이 걸리는 작업인 ORDER BY 정렬 과정을 피할 수 있다.

3. MIN,MAX의 효율적인 처리
    - 인덱스 테이블이 정렬되어 있기 때문에 시작 값과 끝 값만 가져오면 된다.

<h1> 인덱스 단점 </h1>

1. DML에 취약
    - 삽입/갱신/삭제를 통해 데이터가 추가되거나 바뀐다면 인덱스 테이블 내의 값들을 다시 정렬해야 함
2. 속도 향상을 위해 인덱스를 많이 만드는 것은 좋지 않다.
    - 인덱스를 관리하기 위해 데이터베이스에 약 10%에 해당하는 주소 공간이 필요하다. 무턱대고 인덱스를 많이 만들면 데이터베이스의 성능 부하를 초래함

<h1> 인덱스를 사용하기 좋은 경우 </h1>

- 규모가 작지 않은 테이블
- 삽입/갱신/삭제가 자주 발생하지 않는 경우
- JOIN이나 WHERE/ORDER BY가 자주 사용되는 경우
- 데이터의 중복도가 낮은 경우

<h1> 인덱스 구조 </h1>

<h3> 해시 테이블 </h3>

- key-value 한 쌍으로 데이터를 저장하는 자료구조

<h3> B+Tree </h3>

- 리프 노드에만 데이터를 저장하고 리프 노드가 아닌 노드에는 자식 포인터만 저장하는 구조
- 리프 노드끼리는 연결 리스트로 연결되어 있음



<h1> 왜 B 트리를 사용할까? </h1>

- 시간 복잡도에 대해 생각해보자.
![image](https://user-images.githubusercontent.com/62228401/213968336-4d554e6b-5700-4e87-b585-445636eace21.png)
- 일반적으로 위의 그림처럼 평균적으로 생긴 Tree에서 탐색에 대한 시간 복잡도는 O(logN)이다.
![image](https://user-images.githubusercontent.com/62228401/213968400-718facb9-66fb-451f-95e1-dde47fd68238.png)
- 하지만, 위의 그림처럼 Tree의 형태가 한 쪽으로 추욱 늘어진 최악의 경우엔, O(N)이다.
- 이러한 최악의 경우를 대비해서, Balanced Tree를 사용한다.
- Balanced Tree는 항상 좌/우 SubTree 간의 밸런스를 유지하고 있어, 탐색에 대한 시간 복잡도는 O(logN)이다.
- 하지만, 노드 삽입 및 삭제 시 발생하는 재정렬 작업 때문에 탐색을 제외한 작업에서는 일반 Tree보다 성능이 좋지 않다.
- 이러한 Balanced Tree의 예시에는 AVL-Tree, RedBlack-Tree, B-Tree가 있다.


<h3> 왜 HashTable을 쓰지 않고, Balanced Tree를 쓸까? </h3>

- Hash Table이라는 자료 구조는 평균적으로 모든 자료 구조 중 가장 빠른 탐색 시간인 O(1)을 가진다.
- DB 인덱스가 빠른 데이터 조회를 위해 사용하는 것이라면, 왜 Hash Table을 사용하지 않을까?

<h3> 
