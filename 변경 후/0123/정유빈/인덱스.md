<h1> 인덱스 </h1>

- DB 내 저장된 데이터의 "주소"를 갖는 것

![image](https://user-images.githubusercontent.com/62228401/213964304-b0b60ca6-0265-40f1-a3a2-63900c94f4b4.png)
- 위 그림처럼 테이블 내의 1개의 컬럼, 혹은 여러 개의 칼럼을 Key로 삼고, Key에 해당하는 레코드의 물리적 주소 값이 저장되어 있음

- DB 데이터 조회 성능 향상을 위해 사용

<h1> 인덱스 장점 </h1>

1. 조건 검색 WHERE절의 효율성
    - 위 그림처럼, 인덱스 테이블은 정렬되어 저장되어 있기 때문에 해당 조건(WHERE)절에 맞는 데이터를 빠르게 찾아낼 수 있음

2. 정렬 ORDER BY절의 효율성
    - 부하가 굉장히 많이 걸리는 작업인 ORDER BY 정렬 과정을 피할 수 있다.

3. MIN,MAX의 효율적인 처리
    - 인덱스 테이블이 정렬되어 있기 때문에 시작 값과 끝 값만 가져오면 된다.

<h1> 인덱스 단점 </h1>

1. DML에 취약
    - 삽입/갱신/삭제를 통해 데이터가 추가되거나 바뀐다면 인덱스 테이블 내의 값들을 다시 정렬해야 함
2. 속도 향상을 위해 인덱스를 많이 만드는 것은 좋지 않다.
    - 인덱스를 관리하기 위해 데이터베이스에 약 10%에 해당하는 주소 공간이 필요하다. 무턱대고 인덱스를 많이 만들면 데이터베이스의 성능 부하를 초래함

<h1> 인덱스를 사용하기 좋은 경우 </h1>

- 규모가 작지 않은 테이블
- 삽입/갱신/삭제가 자주 발생하지 않는 경우
- JOIN이나 WHERE/ORDER BY가 자주 사용되는 경우
- 데이터의 중복도가 낮은 경우

<h1> 인덱스 구조 </h1>

<h3> 해시 테이블 </h3>

- key-value 한 쌍으로 데이터를 저장하는 자료구조

<h3> B+Tree </h3>

- 리프 노드에만 데이터를 저장하고 리프 노드가 아닌 노드에는 자식 포인터만 저장하는 구조
- 리프 노드끼리는 연결 리스트로 연결되어 있음



<h1> 왜 B 트리를 사용할까? </h1>

- 시간 복잡도에 대해 생각해보자.

![image](https://user-images.githubusercontent.com/62228401/213968336-4d554e6b-5700-4e87-b585-445636eace21.png)

- 일반적으로 위의 그림처럼 평균적으로 생긴 Tree에서 탐색에 대한 시간 복잡도는 O(logN)이다.
![image](https://user-images.githubusercontent.com/62228401/213968400-718facb9-66fb-451f-95e1-dde47fd68238.png)
- 하지만, 위의 그림처럼 Tree의 형태가 한 쪽으로 추욱 늘어진 최악의 경우엔, O(N)이다.
- 이러한 최악의 경우를 대비해서, Balanced Tree를 사용한다.
- Balanced Tree는 항상 좌/우 SubTree 간의 밸런스를 유지하고 있어, 탐색에 대한 시간 복잡도는 O(logN)이다.
- 하지만, 노드 삽입 및 삭제 시 발생하는 재정렬 작업 때문에 탐색을 제외한 작업에서는 일반 Tree보다 성능이 좋지 않다.
- 이러한 Balanced Tree의 예시에는 AVL-Tree, RedBlack-Tree, B-Tree가 있다.


<h3> 왜 HashTable을 쓰지 않고, Balanced Tree를 쓸까? </h3>

- Hash Table이라는 자료 구조는 평균적으로 모든 자료 구조 중 가장 빠른 탐색 시간인 O(1)을 가진다.
- DB 인덱스가 빠른 데이터 조회를 위해 사용하는 것이라면, 왜 Hash Table을 사용하지 않을까?

<h3> HashTable의 치명적 단점 </h3>

![image](https://user-images.githubusercontent.com/62228401/213969681-684a6cfd-73f6-437a-89bb-7c27ff1619a0.png)

- Hash Table은 Hash Function이라는 특정 계산을 하는 함수에 입력 값(Keys)이 들어오면 언제나 같은 해시값을 내뱉는다.
- 그리고 이 결과 값은 Hash Table(buckets)의 index 값으로 매핑되어 찾고자 하는 데이터를 얻을 수 있고, <br />
   미리 저장된 메모리 공간(Hash Table)에 한 번에 접근하기 때문에 O(1)라는 어떠한 자료구조나 알고리즘보다 빠른 탐색 시간을 갖게 된다.<br />
   (물론 Hash 값 충돌이 일어나는 최악의 경우, O(N)이 될 수도 있다.)

- ![image](https://user-images.githubusercontent.com/62228401/213970019-e8f7c094-6671-4292-9c07-0df87b84dde9.png)

- 하지만 위처럼, O(1)이라는 탐색 시간은 "단 하나의 데이터를 탐색하는 시간"이다.
- Hash Table에 저장되는 값들은 정렬되어 있지 않기 때문에, 특정 값보다 크거나 작은 값을 찾을 수 없다.
- 이러한 이유 때문에 Balanced Tree를 사용한다.

<h3> RedBlack-Tree와 B-Tree </h3>

- 두 트리 모두 Balanced Tree이기 때문에 , 데이터 탐색 시간 O(logN)을 보장하는데, 왜 RedBlack-Tree는 DB 인덱스 자료 구조가 되지 못했을까?

![image](https://user-images.githubusercontent.com/62228401/213970353-38927139-1397-49a8-95f3-a9bfd08bc680.png)

- RedBlack-Tree는 각 노드가 하나의 데이터만 가진 상태로, 좌우 SubTREE의 밸런스를 유지한다.
- 노드의 삽입 및 삭제 작업 시, 정해둔 규칙들에 맞게 노드들을 재정렬하며 AVL-Tree보다 약간 완화된 버전이다.

![image](https://user-images.githubusercontent.com/62228401/213970465-f58a2f6e-34e1-47bf-9e30-4a228c66952b.png)

- B-Tree는 하나의 노드에 여러 데이터가 저장 가능한 트리로, Root-Branch-Leaf의 형태를 지닌다.
- 노드 내의 데이터들은 항상 정렬된 상태이며, 해당 데이터들 사이의 범위를 이용하여 자식 노드를 가질 수 있기 때문에, <br />
  노드 내의 데이터의 개수가 N개일 때, 자식 노드의 개수는 N+1개이다.
- 가장 아래 Leaf Node에는 인덱스 Value에 대한 RowID를 저장한다.
- 참고로, 중복된 값의 Row의 비율이 10~15%가 적당하다.

<h3> RedBlack-Tree의 단점 </h3>

- RedBlack-Tree와 B-Tree의 가장 큰 차이는, "하나의 노드 내의 데이터 개수"이다.
- RedBlack-Tree는 하나의 노드 내에 무조건 하나의 데이터만을, B-Tree는 하나의 노드 내에 여러 데이터를 저장할 수 있다.
- Tree 자료구조는, 탐색을 할 때 root 노드부터 원하는 데이터가 나올 때까지 자식 노드로 내려가면서 탐색한다.
- RedBlack-Tree는 하나의 노드에 하나의 데이터만 있기 때문에, 자식 노드로 넘어가는 횟수가 많을 것이고, 그러한 노드와 노드 사이에는 "참조 포인터"로 연결되어 있다.

<h3> B-Tree의 장점 </h3>

- B-Tree는 하나의 노드내에 정렬된 데이터들이 실제 매모리 상에 배열처럼 저장되어 있다.
- 즉, 포인터로 메모리에 접근 시 주소를 알아내는 부가적인 연산이 필요없어, 포인터 접근보다 훨씬 빠르다.
- 따라서, 이론적인 시간 복잡도는 O(logN)이지만, 물리적인 메모리 처리에서 배열 구조의 접근 방식이 굉장히 빠르다.
- 배열은 탐색 시간은 빠르지만, 삽입 및 삭제 시, 평균 O(N), 최악의 경우 O(long N * N)의 시간이 걸린다.


<h3> B-Tree 정리 </h3>

1. 트리 내 모든 데이터가 항상 정렬된 상태로 유지되기 때문에, 등호(=) 연산 뿐 아니라, 부등호 처리도 가능하다.
2. 포인터 접근 방식이 적어 매우 많은 데이터가 있어도 이슈가 적다.
3. 데이터 탐색 뿐 아니라, 삽입 및 수정 삭제에도 항상 O(log N)의 시간 복잡도를 가진다.
