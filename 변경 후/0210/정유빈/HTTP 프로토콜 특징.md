<h1> HTTP(HyperText Transfer Protocol) 특징 </h1>


<h3> 대부분의 파일 형식 전송 </h3>

- HTTP란 HyperText Transfer Protocol의 약자로, HTML 파일을 전송하는 프로토콜이라는 의미를 가지지만, 오늘날에는 거의 모든 파일 형식을 HTTP 통신을 이용해 전송 가능하다.
- 특히 우리가 자주 사용하는 JSON, TEXT, IMAGE 파일은 물론 음성 파일 등도 HTTP를 통해 전송이 가능하다.

<h3> 1. 클라이언트 - 서버 구조 </h3>

- HTTP는 클라이언트의 요청이 있을 때 서버가 응답하는 단방향 통신이다.
- 서버는 클라이언트에 요청을 하지 않으며 클라이언트의 요청에 대한 응답만을 할 뿐이다.

![image](https://user-images.githubusercontent.com/62228401/218007722-122a353c-a3c1-40eb-9b3b-b0186d1c44f1.png)

- 클라이언트의 요청에 대한 서버의 응답에는 요청 처리 결과에 따라 응답 코드가 다르게 온다.
- 따라서 응답 코드 별로 처리 로직을 만들어 서버의 상황에 대한 대응이 가능해진다.

- 예를 들어, 이미지 파일을 요청하는데 URL이 바뀌어 이미지 파일이 해당 경로에 더 이상 없을 때, 서버에서는 다른 경로로 다시 요청하라는 응답을 보낸다.
- 이 때 클라이언트는 해당 경로로 다시 요청을 하여 이미지 파일을 받아올 수 있다.

<h3> 2. Stateless </h3>

- HTTP 통신에서 서버는 클라이언트의 상태를 저장하지 않는다.
- 클라이언트의 상태를 저장하지 않는다는 말은 클라이언트가 이전에 했던 요청이 무엇인지에 따라 반응이 달라지지 않는다는 것이다.
- Stateless가 중요한 이유는 서버가 확장 가능해야 하기 때문이다.
- 보통 대규모 트래픽이 발생하는 서비스에서는 서버가 여러대가 있다.
- 서버가 많아질 수록 서로 간에 정보를 공유하기 위한 비용이 비싸진다.
- Stateless하게 사용할 경우 정보 공유가 최소화되어 정보를 공유하기 위한 비용을 최소화할 수 있다.

<h3> 3. Stateful의 의미와 한계점 </h3>

- 서버가 클라이언트(어플리케이션)의 상태를 저장하는 것을 Stateful이라 한다.
- HTTP에서는 Stateful을 사용하면 정보를 공유하기 위한 비용이 비싸지므로 사용하지 않는다.
- 정보를 공유하기 위한 비용이 왜 비싸지는지 살펴보자.

![image](https://user-images.githubusercontent.com/62228401/218008572-7877c2c5-e123-4ef7-8a8c-9f33791f1659.png)

- 예를 들어 상품 구매 서버를 만든다고 하자.
- 유저는 서버에 상품에 대한 정보를 요청한 후 안마의자가 마음에 들어 안마의자 2개를 주문하려 한다.
- 이 때 유저가 안마의자 상품에 대한 정보를 요청한 것을 서버가 알고 있다면, 이후 유저는 2개를 주문하는 것만 서버에 보내면 된다.

![image](https://user-images.githubusercontent.com/62228401/218008962-98e7ca00-f98b-4c45-a7b6-d54ff3c3b693.png)

- 하지만 서버가 1번부터 100번까지 100개가 잇고 유저가 안마의자 상품에 대해 정보를 요청한 것을 1번 서버만 알고 있다고 하자.
- 유저의 2개 구매 요청을 받은 서버는 100번 서버이다.
- 이 때 100번 서버가 유저가 조회한 것을 알기 위해서는 1~99번 서버에 대해 유적 상품을 조회한 기록이 있는지 살펴봐야 한다.
- 만약 서버가 1000대가 있으면 999개의 서버를 돌아봐야 한다.
- 이렇게 할 경우 너무 비효율적이다.

![image](https://user-images.githubusercontent.com/62228401/218009221-7a80a216-5652-444b-b092-59ab32a6c577.png)

- 클라이언트(어플리케이션)에서 이전에 자신이 요청한 정보를 저장해놓고 해당 메시지를 함께 보내는 것이다.
- "2개 구매" 앞에 "안마의자"까지 포함해서 보냄으로서 서버 100은 나머지 서버에 클라이언트가 이전에 어떤 요청을 하였는지 다른 서버를 조회할 필요가 없게 된다.
- 따라서 서버가 많아지던 말던 다른 서버를 조회하지 않고 서버는 그 클라이언트가 보낸 조회에 대한 응답만 하면 된다.
- 각 서버가 메시지를 독립적으로 처리할 수 있게 되면서 서버의 개수에 비례해서 성능이 올라갈 수 있게 된다.


<h3> 상태를 기억하는 방법 1. - 쿠키 </h3>

- 서비스를 운영하려면 서버가 클라이언트를 기억해야 하는 경우가 많은데, 이러한 문제점을 해결하기 위해 브라우저 단에서 쿠키라는 것을 저장하여 서버가 클라이언트를 식별할 수 있도록 한다.

<h3> 상태를 기억하는 방법 2. - 식별 </h3>

- 쿠키는 사용자 정보가 브라우저에 저장되기 때문에 공격자로부터 위변조의 가능성이 높아 보안에 취약하다.
- 이와 달리 세션은 브라우저가 아닌 서버단에서 사용자 정보를 저장하는 구조이다.
- 따라서 쿠키보다는 안전하다고 할 수 있다.
- 그런데 세션 정보도 중간에 탈취 당할 수 있기 때문에 보안에 완벽하다고 할 수 없다.
- 또한 세션을 사용하면 서버에 사용자 정보를 저장하므로, 서버의 메모리를 차지하게 되고, 만약 동시 접속자 수가 많은 서비스의 경우에는 서버 과부하의 원인이 된다.

<h3> 상태를 기억하는 방법 3 - OAuth , JWT </h3>

- 쿠키와 세션의 문제점들을 보완하기 위해 토큰(Token) 기반의 인증 방식이 도입되었다.
- 토큰 기반의 인증 방식의 핵심은 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용하는 기술이다.
- 그래서 중간에 공격자로부터 토큰이 탈취당하더라도 데이터에 대한 정보를 알 수 없으므로, 보안성이 높은 기술이라 할 수 있다.
- 대표적으로는 OAuth와 JWT가 있다.
- 
<h3> Connectionless </h3>

- HTTP 통신은 연결(Connection)을 유지하지 않는 것을 기본 동작으로 가진다.
- 기본 동작으로는 유지하지 않지만 별도의 옵션을 두면 일정기간동안 유지하게 할 수도 있긴 하다.
- Connection을 유지하지 않는 것을 기본 동작으로 가지는 이유는 Connection을 유지하게 되면 지속적으로 리소스가 사용되기 때문이다.
- 따라서 Connection 유지는 최소화하는 것이 좋다.

<h3> Connection을 유지하는 것이 나은 경우도 있다 </h3>

- HTTP 통신이 생긴 초기에는 서버가 응답한 후 클라이언트(사용자)의 Connection을 곧바로 끊어버렸으나, 최근에는 성능상의 이유(Connection을 맺고 끊는 비용이 비싸다 )로 Keep Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식으로 통신이 가능해졌다.
-  Keep Alive는 지정된 시간 동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 상대방의 안부를 묻기 위해 패킷을 주기적으로 보내는 것을 말한다.
-  이 때 패킷에 반응이 없으면 접속을 끊게 된다.
- 자주 데이터를 요청해야 하는 경우는 Connection을 맺었다가 끊는 것보다 Connection을 일정 기간 유지하는 것이 비용 절감에 도움이 될 수 있다.
- 하지만, 클라이언트의 상태를 체크한다는 것으로 미루어보아 KeepAlive 역시 완벽한 해결책이 아니다.
- KeepAlive 속성이 On 상태라해도, 서버가 바쁜 환경에서는 프로세스 수가 기하급수적으로 늘어나기 때문에, KeepAlive 상태를 유지하기 위한 메모리를 많이 사용하게 되므로 주의해야 한다.


