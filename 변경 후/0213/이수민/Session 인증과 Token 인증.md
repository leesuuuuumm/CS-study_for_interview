## 인증과 인가
- 시스템의 자원을 적절하고 유효한 사용자에게 전달하고 공개하는 방법이다. 

### 인증 (Authentication)
로그인이라 보면 된다. 클라이언트가 자기자신이라고 주장하고 있는 사용자가 맞는지를 검증하는 과정이다. </br>

((예)) </br>
로그인 화면에서 내가 유저 아이디를 User1로 입력하고 패스워드를 입력해 제출하면, 서버는 내가 user1인지 확인한다. </br>

</br>

### 인가 (Authorization)
인증 작업 이후에 행해지는 작업, 인증된 사용자에 대한 자원에 대한 접근 확인 절차를 의미한다. </br>

((예)) </br>
User1, User2가 있다. User1은 글 작성, 조회, 수정, 삭제 등 CRUD 작업에 대한 권한이 부여되어 있다. </br>
하지만 User1은 User2가 작성한 글을 수정하거나 제거할 수 없다. 타인의 리소스에 대해서는 인가되어 있지 않기 때문이다. </br>
또한, User1과 User2는 모두 admin(관리자) 페이지에 접속할 수 없다. </br> 
그 이유는 관리자 페이지에 대해 인가되어 있지 않기 때문이다. </br>

</br>

### HTTP의 비상태성(Stateless)
서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. </br>
HTTP는 바로 직전에 발생한 통신을 기억하지 못한다. </br>
따라서 단독으로는 요청한 클라이언트가 이전에 이미 인증과정을 거쳤는지 알 방법이 없다. </br> </br>

그렇다고, 글을 조회하거나 작성할 때 마다 사용자에게 로그인을 하라고 요청할 수 없다. </br>
그러면 사용자의 아이디와 패스워드를 브라우저에 그대로 저장해놓고, 매 요청마다 그 정보를 함께 보내는 방법은 </br>
데이터가 커져 비효율적이고, 클라이언트에 민감한 데이터가 그대로 저장되어 보안에 굉장히 취약하다. </br>
서버 입장도 매 작업마다 DB를 조회하고, 인증과정을 거치는 것이 비효율적이다. </br> </br>

이런 HTTP 환경에서 서버는 어떤 방식으로 사용자를 인가하냐면 </br>
웹 어플리케이션에서는 이러한 문제를 **새션과 토큰** 을 사용하여 해결한다. </br>
### 즉, 세션과 토큰은 인증 보단 인가와 관련된 기술이라고 할 수 있다.

</br>

## 세션 기반 인증
세션기반 인가는 사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식이다.  </br>

![image](https://user-images.githubusercontent.com/58407737/218355091-103c7be0-ab4b-4545-a005-ada9e032f0fd.png)
 </br>
 
 사용자가 로그인하면, 해당 인증 정보를 서버의 세션 저장소에 저장하고, 사용자에게는 저장된 세션 정보의 식별자인 Session ID를 발급한다.  </br>
 발급된 Session ID는 브라우저에 쿠키 형태로 저장되지만, 실제 인증 정보는 서버에 저장되어 있다.  </br>
 
 브라우저는 인증 절차를 마친 이후 요청마다 HTTP Cookie 헤더에 Session ID를 함께 서버로 전송한다.  </br>
 서버는 요청을 전달받고, Session ID에 해당하는 세션 정보가 세션 저장소에 존재한다면 해당 사용자를 인증된 사용자로 판단한다.  </br>
 

## 토큰 기반 인증 
세션 기반은 인증정보를 서버에 저장하면, 토큰 기반 인증은 인증 정보를 클라이언트가 직접 들고 있는 방식이다. </br>

![image](https://user-images.githubusercontent.com/58407737/218356163-a6552609-7c4d-4327-8c12-aade4b2ddc79.png) </br>

인증 정보가 토큰의 형태로 브라우저의 로컬 스토리지(혹은 쿠키)에 저장된다. </br> 
토큰 종류에 따라 다르겠지만, 대표적인 토큰 **JWT** 의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인할 수 있다. 토큰 종류에 따라 다르겠지만, 

토큰 기반 인증에서는 사용자가 가지고 있는 토큰을 HTTP의 Authorization 헤더에 실어 보낸다. </br> 
이 헤더를 수신한 서버는 토큰이 위변조 되었거나, 만료 시각이 지나지 않은지 확인한 이후 토큰에 담겨있는 사용자 인증 정보를 확인해 사용자를 인가한다. </br> 


</br> </br> 

## 세션기반 인증 VS 토큰기반 인증
### 1. 사이즈
 세션의 경우 Cookie 헤더에 세션 ID만 실어 보내면 되므로 적은 트래픽을 사용한다. </br> 
 
 하지만 JWT는 사용자 인증 정보와 토큰의 발급시각, 만료시각, 토큰의 ID등 담겨있는 정보가 세션 ID에 비해 비대하므로(몸집이 크다) 세션 방식보다 훨씬 더 많은 네트워크 트래픽을 사용한다. </br> </br> 

 단순히 JWT에 iss, sub, nbf, exp, iat, jti, typ 클래임만 실었는데 304 바이트가 나왔다. 그에 비해 세션 ID는 단 6바이트이다.

### 2. 안전성과 보안문제
 세션의 경우 모든 인증 정보를 서버에서 관리하기 때문에 보안 측면에서 조금 유리하다. 설령 세션ID를 탈취당해도, 서버측에서 해당 세션을 무효 처리하면 된다. </br> 
 
 하지만 토큰의 경우 서버가 트래킹하지 않고, 클라이언트가 모든 인증정보를 가지고 있다. 따라서 토큰이 한번 해커에게 탈취되면 해당 토큰이 만료되기 전까지 속수무책으로 피해를 입는다. </br> 
 
 또한, JWT 특성상 토큰에 실린 Payload가 별도로 암호화 되어있지 않으므로, 누구나 내용을 확인할 수 있다.</br> 
 따라서 Payload에 민감한 데이터를 실을 순없다. =   즉, Payload에 실을 수 있는 데이터가 제한된다. </br> 
 
 하지만 세션 경우에는 모든 데이터가 서버에 저장되기 때문에 아무나 함부로 열람할 수 없어 저장할 수 있는 데이터에 제한이 없다. </br>
 
### 3. 확장성

최근 모던 웹 어플리케이션이 토큰 기반 인증을 사용하는 이유는 **확장성** 때문이다.  </br>

일반적으로 웹 어플리케이션의 서버 확장 방식은 수평 확장을 사용한다. 즉, 한대가 아닌 여러대의 서버가 요청을 처리하게 된다. </br>
이때 별도의 작업을 해주지 않는다면, 세션기반 인증 방식은 세션 불일치 문제를 겪게 된다. </br>
이를 해결하기 위해 Sticky Session, Session Clustering, 세션 스토리지 외부 분리 등의 작업을 해주어야한다. </br>

하지만, 토큰 기반 인증 방식의 경우 서버가 직접 인증 방식을 저장하지 않고, 클라이언트가 저장하는 방식을 취하기 떄문에 이런 세션 불일치 문제로부터 자유롭다. </br>
이런 특징으로 토큰 기반 인증 방식은 HTTP 비상태성을 그대로 활용할 수 있고, 높은 확장성을 가질 수 있다. </br>

### 4. 서버의 부담
확장성과 어느정도 이어지는 내용이다. 세션 기반 인증 방식은 서비스가 세션 데이터를 직접 관리하고 저장한다. </br>
따라서 세션 데이터의 양이 많아지면 많아질수록 서버의 부담이 증가할 것이다. </br>

하지만 토큰 기반 인증 방식은 서버가 인증 데이터를 가지고 있는 대신, 클라이언트가 인증 데이터를 직접 가지고 있다. </br>
따라서 서버의 부담 축면에서는 세변 기반 인증 방식보다 토큰 기반 인증 방식이 더 유리함을 알 수 있다. </br>


 </br></br></br></br>
참고: 
https://hudi.blog/session-based-auth-vs-token-based-auth/ </br>
https://tansfil.tistory.com/58
