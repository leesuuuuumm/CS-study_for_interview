<h1> 인증과 인가 </h1>

- 세션 기반 인가와 토큰 기반 인가에 대해 알아보기 이전에, 인증과 인가가 무엇인지 부터 알아야 할 필요가 있다.
- 인증과 인가가 같거나 비슷한 개념이라고 생각하는 사람들이 많을텐데, 엄밀하게는 서로 다른 개념이다.
- 인증과 인가는 요약하자면, <b>시스템의 자원을 적절하고 유효한 사용자에게 전달하고 공개하는 방법</b>이다.

<h1> 인증(Authentication) </h1>

- 인증은 쉽게 말하자면, <b> 로그인 </b> 이다. 클라이언트가 자기자신이라고 주장하고 있는 사용자가 맞는지 검증하는 과정이다.
- 예를 들어 로그인 화면에 유저 아이디를 USER1으로 입력하고 패스워드를 입력해 제출하면, 서버에서는 내가 진짜로 USER1이라는 유저가 맞는지 확인한다.

<h1> 인가 (Authorization) </h1>

- 인가는 인증 작업 이후에 행해지는 작업으로, <b> 인증된 사용자에 대한 자운에 대한 접근 확인 절차 </b> 를 의미한다.
- 일반 유저인 USER1과 USER2가 있다고 가정하자.
- USER1은 글 작성, 조회, 수정, 삭제 등 일반적인 작업에 대한 권한이 부여되어 있다.
- 하지만 USER1은 USER2가 작성한 글을 수정하거나 제거할 수는 없다.
- 타인의 리소스에 대해서는 인가되어 있지 않기 때문이다. 또한 USER1과 USER2는 모두 관리자 페이지에 접속할 수 없다.
- 일반 유저는 관리자 페이지에 대해 인가되어 있지 않기 때문이다.

<h1> HTTP의 비상태성(Stateless) </h1>

- HTTP는 비상태성이라는 특징을 갖는다.
- 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
- HTTP는 바로 직전에 발생한 통신을 기억하지 못한다.
- 따라서 HTTP 단독으로는 요청한 클라이언트가 이전에 이미 인증 과정을 거쳤는지 알 방법이 없다.
- 그렇다고, 글을 조회하거나 작성할 때마다 사용자에게 로그인을 하라고 요청할 수는 없는 노릇이다.
- 매 작업마다 로그인을 사용자에게 요청하는 것은 UX를 전혀 고려하지 않은 방식이다.<br /><br />

- 그렇다면, 사용자의 아이디와 비밀버호를 브라우저에 그대로 저장해놓고, 매 요청마다 함께 그 정보를 보내는 방법은 어떨까?
- 이런 방식은 전송 데이터가 커져 비효율적일 뿐더러 클라이언트에 민감한 데이터가 그대로 저장되어 보안에도 굉장히 취약하다.
- 서버 입장에서도 매 작업마다 데이터베이스를 조회하고, 인증과정을 거치는 것이 비효율적일 것이다. <br /> <br />

- 이런 HTTP 환경에서 서버는 어떤 방식으로 사용자를 인가할까?
- 웹 어플리케이션에서는 이 문제를 세션 또는 토큰을 사용하여 문제를 해결한다.

<h1> 세션기반 인증 </h1>

<h3> 세션이란? </h3>

- 세션이란 정보를 서버 측에 저장하는 방식이다.
- 세션이란, 브라우저로 웹 서버에 접속한 시점부터 브라우저를 종료하여 연결을 끝내는 시점까지 일련의 요청을 하나의 상태로 간주하고, 그 상태를 일정하게 유지하는 기술이다.
- 그렇다면, 이 세션은 어떻게 비상태성을 갖는 HTTP에서 어떻게 상태를 일정하게 유지할까?

<h3> 세션 생성 과정 </h3>

- 맨 처음, 사용자가 HTTP 요청의 Body에 인증 정보(유저 이름이나 패스워드)를 실어 서버에 보낸다.
- 서버에서는 해당 인증 정보가 유효하면 사용자와 데이터를 식별하는 <b> Session ID </b>를 생성한다.
- 생성된 Session ID는 <b> Set-Cookie </b> 헤더에 생성된 Session ID를 실어 보낸다.
- 클라이언트는 해당 Session ID를 쿠키에 저장하고, 매 요청마다 Session ID를 Cookie 헤더에 실어 전송한다.
- 서버는 전달받은 Session ID를 통해 해당 요청의 송신자가 누구인지 식별할 수 있다.

<h5> 주의할 점! </h5>

- 세션 아이디에 대한 쿠키의 Key는 세션을 관리하는 주체에 따라 다르다.
