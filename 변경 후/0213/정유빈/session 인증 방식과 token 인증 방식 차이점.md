<h1> 인증과 인가 </h1>

- 세션 기반 인가와 토큰 기반 인가에 대해 알아보기 이전에, 인증과 인가가 무엇인지 부터 알아야 할 필요가 있다.
- 인증과 인가가 같거나 비슷한 개념이라고 생각하는 사람들이 많을텐데, 엄밀하게는 서로 다른 개념이다.
- 인증과 인가는 요약하자면, <b>시스템의 자원을 적절하고 유효한 사용자에게 전달하고 공개하는 방법</b>이다.

<h1> 인증(Authentication) </h1>

- 인증은 쉽게 말하자면, <b> 로그인 </b> 이다. 클라이언트가 자기자신이라고 주장하고 있는 사용자가 맞는지 검증하는 과정이다.
- 예를 들어 로그인 화면에 유저 아이디를 USER1으로 입력하고 패스워드를 입력해 제출하면, 서버에서는 내가 진짜로 USER1이라는 유저가 맞는지 확인한다.

<h1> 인가 (Authorization) </h1>

- 인가는 인증 작업 이후에 행해지는 작업으로, <b> 인증된 사용자에 대한 자운에 대한 접근 확인 절차 </b> 를 의미한다.
- 일반 유저인 USER1과 USER2가 있다고 가정하자.
- USER1은 글 작성, 조회, 수정, 삭제 등 일반적인 작업에 대한 권한이 부여되어 있다.
- 하지만 USER1은 USER2가 작성한 글을 수정하거나 제거할 수는 없다.
- 타인의 리소스에 대해서는 인가되어 있지 않기 때문이다. 또한 USER1과 USER2는 모두 관리자 페이지에 접속할 수 없다.
- 일반 유저는 관리자 페이지에 대해 인가되어 있지 않기 때문이다.

<h1> HTTP의 비상태성(Stateless) </h1>

- HTTP는 비상태성이라는 특징을 갖는다.
- 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
- HTTP는 바로 직전에 발생한 통신을 기억하지 못한다.
- 따라서 HTTP 단독으로는 요청한 클라이언트가 이전에 이미 인증 과정을 거쳤는지 알 방법이 없다.
- 그렇다고, 글을 조회하거나 작성할 때마다 사용자에게 로그인을 하라고 요청할 수는 없는 노릇이다.
- 매 작업마다 로그인을 사용자에게 요청하는 것은 UX를 전혀 고려하지 않은 방식이다.<br /><br />

- 그렇다면, 사용자의 아이디와 비밀버호를 브라우저에 그대로 저장해놓고, 매 요청마다 함께 그 정보를 보내는 방법은 어떨까?
- 이런 방식은 전송 데이터가 커져 비효율적일 뿐더러 클라이언트에 민감한 데이터가 그대로 저장되어 보안에도 굉장히 취약하다.
- 서버 입장에서도 매 작업마다 데이터베이스를 조회하고, 인증과정을 거치는 것이 비효율적일 것이다. <br /> <br />

- 이런 HTTP 환경에서 서버는 어떤 방식으로 사용자를 인가할까?
- 웹 어플리케이션에서는 이 문제를 세션 또는 토큰을 사용하여 문제를 해결한다.

<h1> 세션기반 인증 </h1>

<h3> 세션이란? </h3>

- 세션이란 정보를 서버 측에 저장하는 방식이다.
- 세션이란, 브라우저로 웹 서버에 접속한 시점부터 브라우저를 종료하여 연결을 끝내는 시점까지 일련의 요청을 하나의 상태로 간주하고, 그 상태를 일정하게 유지하는 기술이다.
- 그렇다면, 이 세션은 어떻게 비상태성을 갖는 HTTP에서 어떻게 상태를 일정하게 유지할까?

<h3> 세션 생성 과정 </h3>

- 맨 처음, 사용자가 HTTP 요청의 Body에 인증 정보(유저 이름이나 패스워드)를 실어 서버에 보낸다.
- 서버에서는 해당 인증 정보가 유효하면 사용자와 데이터를 식별하는 <b> Session ID </b>를 생성한다.
- 생성된 Session ID는 <b> Set-Cookie </b> 헤더에 생성된 Session ID를 실어 보낸다.
- 클라이언트는 해당 Session ID를 쿠키에 저장하고, 매 요청마다 Session ID를 Cookie 헤더에 실어 전송한다.
- 서버는 전달받은 Session ID를 통해 해당 요청의 송신자가 누구인지 식별할 수 있다.

<h5> 주의할 점! </h5>

- 세션 아이디에 대한 쿠키의 Key는 세션을 관리하는 주체에 따라 다르다.
- 즉, 무조건 쿠키에 SESSIONID라는 이름으로 저장되는 것은 아니다.
- 예를 들어, 톰캣은 JSESSIONID라는 이름으로 세션 아이디를 저장하고, node.js는 connect.sid라는 이름으로 저장한다.

<h3> 세션 정보는 어디에 저장될까? </h3>

- 일반적으로 생성된 세션 데이터는 서버의 메모리에 저장된다.
- 하지만 LoadBalancing 등의 이유로 서버를 수평 확장(Scale-Out)하는 경우가 많을 것이다.
- 이런 경우 최초 세션이 생성된 서버와 그 이후의 요청을 받은 서버가 다른 경우 세션이 불일치 하는 문제가 발생할 것이다. </br>
- 이런 문제를 해결하기 위해 유저의 요청이 무조건 세션을 생성한 서버로 향하도록 하는 Sticky Session, 여러 웹서버가 모두 동일한 세션 정보를 가지고 있는 Session Clustering 방식이 있지만, 세션 정보를 관리하는 서버를 아예 별개로 두는 Session Storage 방식이 가장 많이 쓰인다고 한다. </br>
- 이를 위해 MySQL과 같은 RDBMS를 사용할 수도 있겠지만, Key-Value로 저장되는 세션 특성 상 Redis나 memcached와 같은 Key-Value 쌍으로 저장되는 인메모리 스토어를 사용하는 것이 일반적이다.

![image](https://user-images.githubusercontent.com/62228401/218253009-ded0c3bb-9372-46c1-9a37-d5fee9c097e0.png)

- 세션 기반 인가는 사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식이다.
- 사용자가 로그인을 하면, 해당 인증 정보를 서버의 세션 저장소에 저장하고, 사용자에게는 저장된 세션 정보의 식별자인 Session ID를 발급한다.
- 발급된 Session ID는 브라우저에 쿠키 형태로 저장되지만, 실제 인증 정보는 서버에 저장되어 있다.
- 브라우저는 인증 절차를 마친 이후 요청마다 HTTP Cookie 헤더에 Session ID를 함께 서버로 전송한다.
- 서버는 요청을 전달받고, Session ID에 해당하는 세션 정보가 세션 저장소에 존재하면 해당 사용자를 인증된 사용자로 판단한다.

<h1> 토큰 기반 인증 </h1>

![image](https://user-images.githubusercontent.com/62228401/218253098-85bd0a6c-3be8-4e36-9818-582e4aaee5e3.png)

- 세션 기반 인증이 인증 정보를 서버에 저장하는 방식이라면, 토큰 기반 인증은 인증 정보를 클라이언트가 직접 들고 있는 방식이다.
- 이때, 인증 정보가 토큰의 형태로 브라우저의 로컬 스토리지 혹은 쿠키에 저장된다.
- 토큰의 종류에 따라 다르겠지만, 대표적인 토큰인 JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버 측에서 확인할 수 있다.
- 토큰 기반 인증에서는 사용자가 가지고 있는 토큰을 HTTP의 Authroization 헤더에 실어 보낸다.
- 이 헤더를 수신한 서버는 토큰이 위변조 되었거나, 만료 시각이 지나지 않았는지 확인 후 토큰에 담겨있는 사용자 인증 정보를 확인해 사용자를 인가한다.

<h1> 세션 기반 인증 VS 토큰 기반 인증 </h1>

![image](https://user-images.githubusercontent.com/62228401/218253439-ad2740d1-0513-4166-9a42-a68b818061b3.png)

- 세션의 경우 Cookie 헤더에 세션 ID만 실어 보내면 되므로 트래픽을 적게 사용한다.
- 하지만 JWT는 사용자 인증 정보와 토큰의 발급 시각, 만료 시각, 토큰의 ID 등 담겨 있는 정보가 세션 ID에 비해 비대하므로 세션 방식보다 훨씬 더 많은 네트워크 트래픽을 사용한다.

<h2> 차이점 1. 안정성과 보안문제 </h2>

- 세션의 경우 모든 인증 정보를 서버에서 관리하기 때문에 보안 측면에서 조금 더 유리하다.
- 설령 세션 ID가 해커에게 탈취된다고 하더라도, 서버 측에서 해당 세션을 무효 처리하면 된다.
- 하지만 토큰의 경우 그렇지 않다.
- 토큰은 서버가 트래킹하지 않고, 클라이언트가 모든 인증 정보를 가지고 있다.
- 따라서 토큰이 한 번 해커에게 탈취당하면 해당 토큰이 만료되기 까지는 속수 무책이므로 피해를 입을 수 밖에 없다.
- 또한 JWT 특성 상 토큰에 실린 Payload가 별도로 암호화 되어있지 않으므로, 누구나 내용을 확인할 수 있다.
- 따라서 Payload에 민감한 데이터는 실을 수 없다.
- 즉, Payload에 실을 수 있는 데이터가 제한된다.
- 하지만 세션과 같은 경우에는 모든 데이터가 서버에 저장되기 때문에 아무나 함부로 열람할 수 없으므로 저장할 수 있는 데이터에 제한이 없다.

<h4> 안정성 - 세션 </h4>

- 세션은 서버 측에서 저장 / 관리하기 때문에 상대적으로 온전한 상태를 유지하기 유리합니다.
- 하지만 여전히 공격의 위험이 있기에 유효기간, httpOnly, Secure 옵션을 주어 쿠키에 저장합니다.

<h4> 안정성 - 토큰 </h4>

- 반대로 토큰은 웹 브라우저에 저장되기 때문에 공격에 노출될 위험이 큽니다.
- 이러한 경우를 대비해 토큰에는 민감한 정보를 담지 않습니다.
- 그리고, 유효기간을 짧게 설정하여 공격에 노출될 수 있는 시간을 최소화합니다.
- 하지만 짧은 주기로 토큰을 무효화하면 서비스 사용자는 계속 로그인을 해줘야 하는 번거로움이 있기 때문에 애초에 로그인(인증) 시 refresh token이라는 것을 추가적으로 발급합ㄴ디ㅏ.
- refresh token은 좀 더 긴 유효기간을 가졌으며 최대한 안전한 곳에 저장됩니다.
- 기존의 토큰이 만료되거나 변질되면 refresh token을 통해 토큰을 재발급합니다.

<h2> 차이점 2. 확장성 </h2>

- 그럼에도 불구하고 최근 모던 웹 어플리케이션이 토큰 기반 인증을 사용하는 이유가 바로 이 확장성이다.
- 일반적으로 웹 어플리케이션의 서버 확장 방식은 수평 확장을 사용한다.
- 즉, 한 대가 아닌 여러 대의 서버가 요청을 처리하게 된다.
- 이 때, 별도의 작업을 해주지 않는다면, 세션 기반 인증 방식은 세션 불일치 문제를 겪게 된다.
- 이를 해결하기 위해서 Sticky Session, Session Clustering, 세션 스토리지 외부 분리 등의 작업을 해주어야 한다.
- 하지만, 토큰 기반 인증 방식의 경우 서버가 직접 인증 방식을 저장하지 않고, 클라이언트가 저장하는 방식을 취하기 때문에 이러한 세션 불일치 문제로부터 자유롭다.
- 이러한 특징으로 토큰 기반 인증 방식은 HTTP의 비상태성(Stateless)를 그대로 활용할 수 있고, 따라서 높은 확장성을 가질 수 있다.

<h3> 차이점 3. 서버의 부담 </h3>

- 확장성과 어느 정도 이어지는 내용이다.
- 세션 기반 인증 방식은 서비스가 세션 데이터를 직접 저장하고, 관리한다.
- 따라서, 세션 데이터의 양이 많아지면 많아질수록 서버의 부담이 증가한다.
- 하지만, 토큰 기반 인증 방식은 서버가 인증 데이터를 가지고 있는 대신, 클라이언트가 인증 데이터를 직접 가지고 있다.
- 따라서, 유저의 수가 얼마나 되던 서버의 부담이 증가하지 않는다.
- 따라서 서버의 부담 측면에서는 세션 기반 인증 방식보다는 토큰 기반 인증 방식이 조금 더 유리함을 알 수 있다.






