<h1> 인터럽트 </h1>

- <b> CPU가 프로그램을 실행하고 있을 때 </b> I/O 하드웨어 장치에 <b> 예외상황이 발생 </b> 하여 처리가 필요한 경우 <b> CPU에게 알려 처리할 수 있도록 하는 것 </b>을 말한다.
- CPU의 정상적인 프로그램 실행을 방해했다는 의미
- 운영체제는 디바이스를 폴링하는 대신에 I/O 요청한 프로세스를 <b> 블록 시키고 CPU를 다른 프로세스에게 양도 </b>한다.
  장치가 끝마치면 하드웨어 인터럽트를 발생시키고 CPU는 운영체제가 미리 정의해놓은 <b> 인터럽트 서비스 루틴(ISR) </b> 또는 <b> 인터럽트 핸들러(Interrupt Handler)</b>를 실행한다.
  - 인터럽트 핸들러는 <u> 입출력 요청, I/O 대기중인 프로세스 깨우기 </u> 등을 하여 프로세스가 작업을 계속 할 수 있도록 한다.
  
 </br>
- 하나의 CPU에서는 매 순간 하나의 프로그램만 실행시킬 수 있음
- 그렇기 때문에 현재 CPU를 할당받아 실행하고 있는 프로그램이 I/O 처리와 같이 수행하는데 오래 걸리는 작업을 할 때도 CPU를 점유하고 있다면, CPU라는 비싼 자원을 낭비하게 됨
- 따라서 운영체제는 자원의 효율적 관리라는 가장 중요한 목표를 달성하기 위해, <b> 인터럽트 </b> 라는 방식을 사용한다. 
- 즉, 프로그램이 당장 처리해야 하는 작업이 발생하면, 다른 처리를 하도록 일시 정지시킨 뒤, 그 동안 CPU를 다른 프로그램에게 할당하여 자원을 낭비하지 않도록 만드는 것이다.

<br/>

- CPU가 프로세스 a를 실행 중일 때, 파일 읽기의 끝이 나서 block 상태에서 running 상태로 돌아가야 한다고 가정해보자.
- 그럼 누가 CPU에게 파일 읽기가 끝났다고 알려줄까?
- 바로 인터럽트 기술이 기본적으로 OS에 구현되어 있기 때문에 가능하다.
- 인터럽트는 일종의 이벤트로 CPU에게 정보를 알려주는 기술이다.
- CPU가 실행 중인 프로세스를 강제 중단하고, 다른 프로세스로 갈아타게 만드는 걸 스케쥴러가 담당하는데, 이 스케쥴러 코드를 실행하는 것이 인터럽트이다.

<h3> 인터럽트 발생 상황 예시 </h3>

- CPU가 코드가 한 줄 한 줄 읽는데 집중하다가, 인터럽트가 필요하면 즉시 실행을 멈춘다.
- 이 때, 실행을 멈춰야 하는 3가지 주요 상황이 있다.

<b> 인터럽트 상황 1. 입출력 하드웨어에 문제/이벤트가 발생했을 때 </b>

- <b> CPU의 하드웨어 신호에 의해 발생 </b>
- 외부 인터럽트, 하드웨어 인터럽트라고 하며 파일 처리가 끝났을 때나, 하드웨어 전원이 이상이 있거나, 발열이 심하거나 하는 경우 CPU의 동작을 멈춘다.

<b> 인터럽트 상황 2. 예외 상황이 발생했을 때 </b>

- <b> 잘못된 명령이나 데이터를 사용할 때 발생 </b>

- 내부 인터럽트, 소프트웨어 인터럽트(트랩) 라고 하며 프로그램 내부에서 예외상황이 발생했을 때 처리한다.
- 흔히 0으로 나누는 exception이나, 포인터로 잘못 커널 모드를 접근했을 때, 계산 결과가 overflow/underflow되었을 때 등의 상황이다.
- 사용자가 운영체제에만 사용할 수 있는 자원에 액세스하는 "사용 권한 위배" 경우에도 발생한다.

<b> 인터럽트 상황 3. 타이머 인터럽트 </b>

- 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청
- CPU가 실행중인 프로세스를 다른 프로세스로 변경하고 싶으면, 타이머 인터럽트를 CPU에게 알려준다.
- 멀티 프로그래밍 실현을 위해 프로세스는 1초에 100번 이상 변경이 되는데 그 단위 기간마다 스케쥴링을 해주는 것이다.
- 선점형 스케쥴러를 위해 필요한 인터럽트이다.


<h3> 인터럽트 내부 동작 방식 </h3>

- 프로세스 전환이나 실행시간 만료로 인한 인터럽트가 발생했을 때, CPU는 프로세스를 중단하고 다른 프로세스로 갈아탄다.
- 그걸 가능하게 하는 신호는 '시스템 콜(System call)이라고 ㅎ나다.
- 시스템 콜은 커널 모드에서 직접적으로 OS에 명령을 내릴 수 있는 함수이기 때문에 일반적으로 프로그래밍을 할 때의 '사용자 모드'에서 '커널 모드'로 돌아간 다음에 실행을 해야 한다.

![image](https://user-images.githubusercontent.com/62228401/223286535-52464902-c0b5-4223-a876-62c7821145cf.png)

위 그림을 살펴보자.

1. CPU가 콜을 받아서 사용자 모드에서 커널 모드로 바꿔준다.
2. IDT 인터럽트 번호에 해당하는 주소(함수)를 찾아 실행한다.
3. 시스템 콜에서 exe로부터 시스템 번호를 찾아서, 해당 번호에 맞는 시스템 콜 함수로 이동한다.
4. 커널 모드에서 시스템 콜 함수 실행 후, 사용자 모드로 전환하여 프로세스 다음 함수를 진행한다.


- IDT(Interrupt Descriptor Table)에는 이벤트 신호와 실행코드 주소가 매칭되어 있다.
- 그래서 인터럽트가 발생하면 IDT를 확인하여 시스템 콜에 해당하는 번호(0X80)을 받아와 시스템 콜을 실행시키는 것이다.
- 사용자/커널 모드를 오가면서 프로세스를 중지시키고 재시작 하는 모습을 다음과 같이 그림으로 나타낼 수 있다.
- 수시로 위아래로 왔다갔다 하는 모양이고 이는 1초에 100번 이상 수행된다.

![image](https://user-images.githubusercontent.com/62228401/223286968-5bb350e7-e57f-4d4a-b9ef-7593dcd7cb9a.png)

- 정리하자면
1. 인터럽트 발생
2. 현 프로세스 실행 중단
3. 커널 모드에서 IDT 확인 후 인터럽트 해당 번호 실행
4. 사용자 모드로 돌아와 다음 코드 실행

<h3> 인터럽트의 발생은 어떻게 감지? </h3>

- 인터럽트의 발생은 CPU 옆에 있는 인터럽트 라인(Interrupt Line)이 감지
- CPU가 하나의 명령어를 실행할 때마다 인터럽트 라인을 확인하며 인터럽트가 발생했는지 확인하는 것이다.

<h3> 인터럽트 처리 방법? </h3>

- 인터럽트가 발생하면 CPU는 현재 수행중이던 작업을 멈추고, 인터럽트와 관련된 일을 처리한다.

<h2> 인터럽트 종류 </h2>

- 소프트웨어 인터럽트
- 하드웨어 인터럽트

<h1> 소프트웨어 인터럽트 </h1>

- 소프트웨어 인터럽트는 예외 상황, 시스템 콜 등이 있다.

- <b> 예외 상황 </b>
  - 프로세스가 0으로 나누는 연산 등 불가능한 작업을 시도하거나, 자신의 메모리 영역 바깥을 접근하려는 시도를 할 때 이에 대한 처리를 위해 발생시키는 인터럽트이다.
- <b> 시스템 콜 </b>
  - 프로그램이 자신이 작성하지 않은 코드를 운영체제로부터 서비스를 받기 위해 발생시키는 인터럽트이다.
 
<h1> 하드웨어 인터럽트 </h1>

![image](https://user-images.githubusercontent.com/62228401/223285204-997d9fe1-f0ae-4992-97f8-5016249bc14f.png)

- 컴퓨터와 연결되는 하드웨어에는 기본적으로 하드웨어의 CPU와도 같은 역할을 하는 컨트롤러와 로컬 버퍼라는 작은 메모리가 존재한다.
- 프로그램이 하드웨어에 어떤 데이터를 요청하면, 하드웨어는 필요한 데이터를 하드웨어의 로컬 버퍼에 임시로 저장한다.
- 그리고 로컬 버퍼에 프로그램으로 전달할 데이터가 충분히 쌓이면 프로그램으로 데이터를 전달하기 위해 CPU 작업을 요청하는데, 이때 작업 요청을 위해 하드웨어의 컨트롤러가 인터럽트를 발생시킨다.
- 이를 하드웨어 인터럽트라고 한다.
- 즉, 하드웨어 인터럽트는 하드웨어가 요청된 데이터를 모두 준비했다고 CPU에 알리는 방법이다.

<h1> 인터럽트 핸들링 </h1>

- 인터럽트는 소프트웨어 혹은 하드웨어에 의해 발생한다.
- 소프트웨어든 하드웨어든 인터럽트가 발생하면 CPU는 현재 수행하던 작업을 멈추고, 발생한 인터럽트를 처리하기 위한 절차를 거친다.

인터럽트 핸들링을 간단하게 요약해보겠습니다.
(프로그램 A가 현재 CPU를 할당받아서 실행되고 있다고 가정한다.)

1. A의 현재 상태 저장
2. 인터럽트 백터에서 인터럽트 서비스 루틴의 주소를 찾음
3. 인터럽트 서비스 루틴의 주소로 이동해서 서비스 루틴 실행
4. 인터럽트 서비스 루틴이 모두 실행되면, A의 상태 복원

각 과정에 대해 조금 더 자세하게 알아보겠습니다.

<b> 1. A의 현재 상태 저장 </b>

- 인터럽트가 발생하며 현재 실행되고 있는 프로그램 A의 상태를 저장한다.
- 왜냐하면 CPU는 명령어를 수행하기 위해 임시 기억 장치인 '레지스터'에 명령어를 불러와 실행시키는데, 인터럽트가 발생하면 새로운 명령어를 실행시키기 위해 레지스터에 있는 값이 초기화되기 때문이다.
- 따라서, 인터럽트 처리 후 인터럽트가 발생한 지점부터 프로그램을 다시 실행시키기 위해서는 현재까지 실행한 A의 상태를 저장해두어야 합니다.
- A의 상태를 저장하기 위해서 사용하는 값들은 PCB라고 불리는 프로세스가 실행될 때 만들어지는 자료구조에 저장되어 있다.

![image](https://user-images.githubusercontent.com/62228401/223283706-4290b163-30a5-4142-9390-8949f24baa96.png)

<b> 2. 인터럽트 벡터에서 인터럽트 서비스 루틴의 주소를 찾음 </b>

- 운영체제의 전부를 메모리에 항상 적재시키는 것은 어렵기 때문에, 우리는 운영체제의 가장 핵심적인 부분인 커널만을 메모리에 상주시켜놓습니다.
- 즉, 운영체제 역시 메모리에 존재하는 프로그램입니다.
- 인터럽트 처리는 커널의 코드를 수행하는 것을 말합니다.
- 따라서 인터럽트를 처리하기 위해서는 커널이 실행되도록 CPU를 할당한 뒤, 커널에 존재하는 인터럽트 처리 코드의 시작 주소를 찾아야 합니다.
- 이 주소는 인터럽트 벡터라고 불리는 각 인터럽트 처리 코드의 시작 주소를 갖고 있는 테이블에 저장되어 있습니다.
- 다시 말해, 인터럽트가 발생하면 커널에서 인터럽트를 처리하는 코드를 실행시키기 위해 처리 코드의 시작 주소가 저장되어 있는 인터럽트 벡터를 참고해 주소를 찾아야 합니다.

<b> 3. 인터럽트 서비스 루틴의 주소로 이동해서 서비스 루틴 실행 </b>

- 인터럽트 서비스 루틴은 발생한 인터럽트를 실질적으로 처리하는 코드를 말합니다.
- 서비스 루틴 코드가 모두 실행되면 해당 인터럽트가 해결됩니다.

<b> 4. 인터럽트 서비스 루틴이 모두 실행되면, A의 상태 복원 </b>

- 인터럽트 처리가 끝나면, PCB에 저장된 프로그램 A의 다음 실행 주소를 불러온 뒤, 코드의 나머지 부분을 수행한다.


<h3> 알아두면 유용한 것들 </h3>

<b> Q. 인터럽트 처리 중, 또 다른 인터럽트가 발생한다면? </b>

- 원칙적으로 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것은 허용하지 않는다.
- 이는 데이터의 일관성을 유지하기 위함이다.
- 예를 들어, 인터럽트가 발생해서 운영체제 커널에 정의된 데이터를 변경하고 있는 상황에 또 다른 인터럽트가 발생해서 같은 데이터를 수정하게 된다면, 데이터가 원래 의도하지 않았던 값으로 변경될 수도 있다.
- <b> 그러나, 예외가 존재할 필요성도 있다. </b>
- 예를 들어, 현재 인터럽트 처리 루틴보다 훨씬 급하고 중요하게 처리해야 할 인터럽트가 발생하는 경우이다.
- 이 때는 현재 처리 중이던 인터럽트 코드의 수행 지점을 커널 스택에 저장한 뒤, 우선적으로 처리할 인터럽트를 처리한 뒤, 이전에 실행 중이던 인ㅌ럽트 코드 부분으로 되돌아와 남은 부분을 처리하게 된다.

<b> Q. PCB란? </b>

- 오늘날의 컴퓨터의 운영체제(OS)는 인터럽트가 발생할 때만 실행한다.
- 시스템 부팅 후 정상 상태에서는 CPU는 항상 사용자 프로그램에 의해 사용되고, OS는 인터럽트가 발생한 경우에만 잠시 CPU 제어권을 가질 수 잇다.
- 즉, OS가 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않는다.

<b> Q. 인터럽트 핸들링을 간단히 설명한다면? </b>

- 인터럽트가 발생한 후 처리해야 할 일의 절차
- CPU에서 명령이 실행될 때 CPU 내부의 임시 기억장치인 레지스터(Register)에서 데이터를 읽거나 쓰면서 작업을 하는데, 이 때 인터럽트의 발생으로 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지게 되므로 CPU 내의 이러한 상태를 저장한 이후에 인터럽트 처리가 이루어질 수 있도록 한다.
