### 인터럽트와 시스템 콜은 운영체제에서 컴퓨터 시스템의 동작을 제어하는데 중요한 역할을 하지만, 서로 다른 목적을 가지고 있다.
</br>

인터럽트와 시스템 콜에 대해 살펴보자.
</br>

### 싱글 코어 CPU에서 한 번에 하나의 프로세스만 동작하는데, 이 때 I/O가 발생하거나, 프로그램에 문제 생기면 실행중인 프로세스는 잠시 동작을 중지시켜야하는데, 이걸 누가 처리할까?

### 또한, I/O는 실제로 일반 프로그램이 하는 것이 아니라, OS 측에서 담당해야하는 것이다.

</br>


# OS의 동작 과정 - Dual Mode
- Os가 서로 다른 두개의 모드로 돌아간다는 것을 의미한다.
- 사용자 모드 (User Mode): 일반적인 응용프로그램이 구동되는 환경이다.
- 커널 모드 (Kernel Mode): 커널이 구동되는 환경이며, 이 모드에서는 OS 시스템에 영향을 주는 명령어를 실행할 수 있다.

</br>

![image](https://user-images.githubusercontent.com/58407737/227553473-b21adc4e-9af6-437a-9fa0-dad92f23e720.png)

</br>

처음 OS가 구동되면 초기화 작업 및 부팅 과정에서 필요한 과정들을 수행하기 위해 커널 모드로 시작되지만, 곧 사용자 모드로 전환된다. </br>

프로그램을 사용하면 **인터럽트**나 **트랩**이 발생되면 모든 비트를 0으로 전환하고, 운영체제의 모드 또한 커널 모드로 변경된다. </br>


## 두 모드로 분리하는 이유

유저 어플리케이션이 함부로 운영체제의 치명적인 데이터를 수정하거나 삭제하지 못하기 하기 위해서이다. </br>
-> 응용 프로그램이 전체 컴퓨터 시스템에 접근할 수 있기 때문이다. </br>

응용 프로그램은 프로그래밍 언어를 다루는 사람들 (개발자)이라면 누구나 만들 수 있기 떄문이다. </br>

운영체제의 경우, 시스템에 영향을 끼칠 수 있는 몇몇 명령어를 특권 명령(Privileged Instruction) 으로 지정함으로써 운영체제 자신을 보호한다. </br>
if, 응용 소프트웨어가 해당 명령을 시행하려고 접근하게 되면, OS 측에서 잘못된 접근으로 인식하여 트랩을 걸어 프로그램을 중단 시킨다. 


 

### 예제 
![image](https://user-images.githubusercontent.com/58407737/227557042-8830362a-13c5-44d2-ba60-68cd9d1b8f97.png) </br>

</br>

### CPU 구조 (Intel 기준)
![image](https://user-images.githubusercontent.com/58407737/227555570-d9d3f71c-2cc5-4f90-84dd-deac1c342d38.png) </br>

- 지구처럼 층이 존재하고, 외부일 수록 낮은 권한 모드, 내부일 수록 높은 권한 모드이다.
- 가장 내부에 있는 Ring 0을 Kernel이라고 한다.

- User Mode는 Ring 3에 속하고 일반적인 응용 프로그램이 사용하는 명령이 있다.
- Kernel Mode는 Ring 0에 속하며 운영체제에서 특권 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케 한다.

</br>

###  응용 프로그램과 운영체제
 C나 Java 등 컴퓨터 언어로 만든 모든 프로그램은 OS 위에서 작동한다. 그리고 프로그램은 커널 모드에서만 실행 가능한 기능들을 사용하는 경우가 있다. </br>
 파일을 여는 함수 Open()이 대표적인 예이다. </br>
 즉 커널 모드로 기능을 실행하려면 반드시 시스템 콜을 거쳐야한다. </br>
 -> 응용 프로그램에서는 CPU를 실행할 수 었다.  </br>
 
 OS는 응용 프로그램이 커널 모드 기능을 실행하기 위해 시스템 콜을 제공해줘야한다. 

</br>
</br>

# 인터럽트
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에서 이슈나 예외 상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술이다. </br>
- 어떤 프로세스나 이벤트가 즉각적인 주의를 요할 때 하드웨어나 소프트웨어가 보내는 신호다.
- 현재 수행중인 프로세스의 중단을 요청하고, 우선순위가 높은 프로세스가 있음을 프로세서에게 알힌다.
- 다양한 요인에 의해 발생할 수 있는데 크게 외부 인터럽트, 내부 인터럽트로 나눈다.

내부 인터럽트는 다른 말로 트랩이라고 한다. 즉, 내부 인터럽트는 인터럽트라고 볼 수 없지만 보통은 묶어서 본다.  </br>

</br>

### 외부 인터럽트
- 주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)
- 전원 이상
- 기계 문제
- 키보드 등 IO 관련 이벤트
- Timer 이벤트

-> 외부 인터럽트는 주로 하드웨어에서 발생하므로, 하드웨어 인터럽트라고도 함

</br>

### 내부 인터럽트 (= 트랩)
잘못된 명령이나 잘못된 데이터를 사용할 때 발생한다. 다른 말로 프로그램 검사 인터럽트라 부르는데 크게 다음과 같은 것들이 있다.
- Division By zero: 0으로 나눴을 때
- Overflow/ Underflow: 계산 결과가 오버/언더 날때
- 기타 프로그램 Exception: 사용자 모드에서 허용되지 않은 명령 또는 공간 접근 시

-> 내부 인터럽트는 주로 프로그램 내부에서 발생하여, 소프트웨어 인터럽트라고도 함

</br>

## 인터럽트의 동작 과정
![image](https://user-images.githubusercontent.com/58407737/227566157-37ee399e-0369-40e3-8b9b-7869ecc094e5.png) </br>

### 1. 인터럽트 요청
### 2. 프로그램 실행 중단: 현재 실행중이던 명령어까지 수행한다.
### 3. 현재의 프로그램 상태 보존: PC의 값을 스택에 저장한다. (인터럽트 종료 후 복귀를 위해)
### 4. 인터럽트 처리루틴 실행: 인터럽트를 요청한 장치를 식별한다.
### 5. 인터럽트 서비스 루틴 (ISR) 실행: 인터럽트 원인을 파악하고 실직적인 작업을 수행한다. 처리기 레지스터 상태를 보존한다. 서비스 루틴 수행 중 우선순위가 더 높은 인터럽트가 발생하면 또 재귀적으로 1 ~ 5를 수행한다.
### 6. 상태복구: 인터럽트 발생 시 저장해둔 PC를 다시 복구한다.
### 7. 중단된 프로그램 실행 재개: PC의 값을 이용하여 이전에 수행중이던 프로그램을 재기한다.

ISR을 처리하기 전, 현재 수행하던 작업을 스택에 저장하는 과정을 거치는 것을 볼 수 있는데, 다른 말로 Context를 저장한다라는 말이다. </br>
*context: 프로세스의 상태와 관련된 레지스터의 집함을 의미함
</br> 
인터럽트 요청 회선 방식: https://mindstation.tistory.com/164 </br>

</br>
</br>

# 시스템 콜
응용 소프트웨어는 커널 모드에 직접적으로 접근할 수 없다. </br>
그래서 프로세스가 시스템의 자원이나, 서비스를 필요로 할 경우 운영체제에게 요청할 수 있는데 이것을 시스템 콜이라한다. </br>
-> 커널 모드를 통한 작업은 반드시 시스템 콜을 통해 수행하도록 설계 되어 있음.
</br>

## 시스템 콜의 동작 과정
![image](https://user-images.githubusercontent.com/58407737/227571539-67c52a4f-3782-4405-a49b-2fd3d3981f7a.png)
</br>

### 사용자 프로세스가 시스템 콜을 요청하면 제어가 커널로 넘어온다. (사용자 모드 -> 커널 모드)
### 커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유번호를 할당하고, 그 번호에 해당하는 제어루틴을 커널 내부에 정의한다.
### 커널은 요청받은 시스템 콜에 대응하는 기능번호를 확인한다.
### 커널은 그 번호에 맞는 서비스 루틴을 호출한다.
### 서비스 루틴을 모두 처리하고 나면 커널모드에서 사용자 모드로 다시 전환된다. 

==========================================

### 응용 프로그램에서 시스템 콜을 호출하면, 0x80 인터럽트가 발생한다.
### IDT(Interrupt Descripter Table: 인터럽트의 종류를 판단하기 위해 사용함) 에서 0x80은 System_call()이기 떄문에, 커널이 시스템 콜과 관련된 동작을 수행한다.

### 필요한 기능이나 시스템 환경에 따라 시스템 콜을 발생할 때 좀 더 많은 정보가 필요할 수 있다. 그러한 정보가 담긴 매개변수를 OS에 전달하기 위해서는 3가지 방법이 있다. 

1. 매개변수를 CPU 레지스터 내에 전달한다. 이 경우에는 매개변수의 개수가 CPU 내의 총 레지스터 개수보다 많을 수 있다.
2. 위와 같은 경우에 매개변수를 메모리에 저장하고 메모리의 주소가 레지스터에 전달된다.
3. 매개변수는 프로그램에 의해 스택으로 전달될 수 있다. 

</br>

![image](https://user-images.githubusercontent.com/58407737/227574629-5f10ed86-05c8-4e81-b480-8519995b31b0.png)

</br>

# 인터럽트 VS 시스템 콜
인터럽트는 예외 상황을 처리하기 위한 메커니즘이며, 시스템 콜은 응용 프로그램이 운영체제의 기능을 호출하기 위한 인터페이스이다. 


