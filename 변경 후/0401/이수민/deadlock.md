# Deadlock(= 교착상태)

</br>

![image](https://user-images.githubusercontent.com/58407737/229269483-a1b7c792-867f-49d3-af23-07dc673f5ef0.png) </br>


p1이 r1을 가지고 있고, p2는 r2를 가지고 있다. </br>
그러나 p2는 r1이 필요하고, p1는 r2가 필요하는데 서로 필요한 걸 가지고 있지만, 이 요구가 뒤엉킨 상태로 계속 서로가 갖고 있는 자원을 받을 때까지 무한정으로 대기 하게 되는 것이다. </br>
*p1: process 1,  r1: resource 1, p2: process 2, r2: resource 2 </br>


### 즉, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 뜻한다.


</br>

### 생긴 이유? 

초기에 있던 일괄 처리 시스템에서는 교착 상태가 자주 발생하지 않았다. </br>
시스템 효율을 증가시키고 제한된 자원의 사용률을 높이기 위해 사용하는 병행 처리 기술과 자원 공유 기술로 교착상태이라는 부작용이 생긴 것이다.

</br>

순서 : 자원 요청 -> 자원 사용 -> 자원 해제 </br>

이때 자원 요청, 해제는 system call로 한다.  </br>


</br>
</br>

# 발생 조건

### 1. 상호 배제
- 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.
- 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

</br>

### 2. 점유와 대기
- 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다. 

</br>

### 3. 비선점
- 이미 할당된 자원을 강제로 뺴앗을 수 없다. 
- 프로세스가 자원 사용을 마친 후 자원을 되돌려(해제) 한다고 했었는데 이때, 자원을 강제로 뺴앗는 것이 아니라 자원을 점유하고 있는 프로세스가 해당 자원을 되돌려(해제)해야 한다는 것이다. 

</br>

### 4. 순환 대기
![image](https://user-images.githubusercontent.com/58407737/229270726-9df6dc2f-db60-475d-abe1-fced8b895126.png) </br>

- 위의 그림과 같이 대기 프로세스 집합 {P0, P1, ..., Pn }이 있을때 P0은 P1이 보유한 자원을, P1은 P2, Pn-1은 Pn이 보유한 자원을 Pn은 P0이 보유한 자원을 각자 얻으려고 기다리는 것을 순환 대기라 한다. 


</br>

### 4가지 조건을 예시로 표현한 것 
![image](https://user-images.githubusercontent.com/58407737/229270919-288085e5-15b1-48c3-8aa3-f9973b82124d.png) </br>
 
![image](https://user-images.githubusercontent.com/58407737/229270931-d1d19ba0-53aa-41dc-88c1-763c8a9dd38c.png) </br>

</br>

# Deadlock 해결 방안 
## 1. 데드락이 발생하지 않도록 예방(prevention) 하기
- 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

**1. 자원의 상호 배제 조건 방지** </br>
- 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다. -> 동기화 관련 문제 발생 가능성 있음

**2. 점유 대기 조건 방지** </br>
- 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다. </br>

**3. 비선점 조건 방지** </br>
- 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 떄, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.

**4. 순환 대기 조건 방지** </br>
- 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다. 

</br>

이러한 예방 방법은
### 시스템의 처리량이나 효율성을 떨어트리는 단점이 발생할 수 있다.

</br>

그래서, 예방법보다는
### 조건 덜 제한적인 방법으로 예방법의 단점 일부를 해결하는 회피법이 있다.

</br></br>

## 2. 데드락 발생 가능성을 인정하면서도 적절하게 회피(avoidance) 하기
**Sage squence, Safe state 등이 키워드** </br>

시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 **안정상태(safe state)** 에 있다고 말한다. </br>

그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 **데드락이 발생하지 않는 순서를 찾을 수 있다면**, 그것을 **안전 순서(Safe safe sequence)** 라 한다. </br>

![image](https://user-images.githubusercontent.com/58407737/229272382-f8b0a5dc-ea41-47cf-917d-c76e8b791a8f.png) </br>

반면 **불안정 상태** 는 데드락 발생 가능성이 있는 상황이고, 데드락은 불안정 상태일 때 발성할 수 있다. </br>
불안정 상태가 교착 상태보다 더 큰 집합이다. (즉, 교착 상태가 불안정 상태의 부분집합)

</br>

이처럼 회피 알고리즘은 **자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자** 라는 것이 기본 특징이다.  </br>

이러한 특징을 살린 알고리즘이 **은행원 알고리즘** 이다. 

</br></br>

### 은행원 알고리즘 (Banker's Algorithm)
- 다익스트라가 제안한 기법
- 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사한다.
- 즉, 대기중이던 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것이다.
- 은행원 알고리즘에서 운영체제는 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을떄까지 계속 거절한다. 


### (예시)

![image](https://user-images.githubusercontent.com/58407737/229272900-e0a02028-0c21-4d30-a7c2-7ea3eeaed895.png) </br>

1. 100달러를 가지고 있는 은행이 있고, 돈을 빌려달라는 고객이 3명이 있다. 
2. 고객은 필요한 돈이 다 있어야만 일을 해결할 수 있고 빌린 돈을 상환할 수 있다. (즉, 30달러가 필요하다.20달러만 있으면 상황 해결이 안된다.)
3. 고객 1은 60달러, 고객 2는 40달러, 고객3은 50달러가 필요하다.
4. 은행은 일단 고객1에게 20달러, 고객2와 고객3에게 30달러 빌려줬다.
5. 그러면 20+30+30 = 80달러이며  
6. 100 - 80 = 20은 은행이 수중에 가지고 있는 돈이다.
7. 그런데 아직 고객1은 40달러, 고객2는 10달러, 고객3은 20달러가 추가적으로 필요한 상황이다.

</br>

#### How? 
1. 남은 20달러 중에 10달러를 고객 2에게 빌려주고 그 고객이 어려운 상황을 해결하고 돈을 갚을 때까지 기다린다. 은행은 10달러밖에 남지 않았지만, 고객2가 해결해 40달러를 다시 돌려 받으면 50달러가 생기므로 고객1이나 고객3을 도울 수있다. 

2. 20달러를 고객3에게 빌려주고 그 고객이 해결할 때까지 기다린다.

#### 하지만, 고객1에게 돈을 빌려주면 해결되지 않는다.(방법이 통하지 않는다) 
#### 20달러밖에 없는데 고객1은 추가적으로 필요한 돈이 40달러이기 떄문이다. 

#### 그래서 첫 번째 방법이나 두 번쨰 방법으로 해결하고 돈을 충당한 후 남은 고객1을 해결해 준다.

</br>

이렇게  모든 고객들에게 결국 돈을 빌려주고 은행이 다시 돈을 돌려받을 수 있는 상태를 **안정상태**라고 한다. </br>

1. 고객2 - 고객1 - 고객3
2. 고객2 - 고객3 - 고객1
3. 고객3 - 고객1 - 고객2
4. 고객3 - 고객2 - 고객1

</br>

이런 순서로 모든 고객의 상황을 해결해 줄 수 있고 이를 **안전 순서열** 이 존재한다고 한다. 

</br> 

![image](https://user-images.githubusercontent.com/58407737/229274060-14a3df05-9055-403a-8841-036a7e083d2b.png) </br>

하지만, 고객1이 갑자기 35달러가 필요해서 빌려줬으면 은행에는 5달러밖에 안남는다. 이러면 고객 3명다 해결을 해주지 못한다. </br>

이러한 상태를 **불안정상태 또는 데드락** 이라고 한다. </br>

### 즉 은행원 알고리즘은 최소한 고객 한명에게 대출해줄 금행은 항상 은행이 보유하고 있어야한다 는 개념에서 나왔다.

</br>

### 은행원 알고리즘을 수행하기 위해 필요한 것
1. 각 고객들이 얼마나 맥시멈으로 돈을 요구할지 [Max] 
- 각 프로세스가 자원을 얼마나 요청할 수 있는지

</br>

2. 각 고객들은 현재 빌린 돈이 얼마 인지 [Allocated]
- 각 프로세스가 현재 보유하고 있는 자원은 얼마인지

</br>

3. 은행이 보유한 돈이 얼마인지, 빌려줄 수 있는 돈이 얼마인지 [Available]
- 시스템이 얼마나 자원을 보유하고 있는지 

### 프로세스 예시
</br>

시스템에 총 12개의 자원을 가지고 있다. </br>

![image](https://user-images.githubusercontent.com/58407737/229272612-ce72513b-94d6-4fdd-ac06-4f65318a36ee.png) </br>

- P0 ~ P2는 프로세스
- Max는 각 프로세스마다 최대 자원 요청량
- Allocation은 현재 프로세스에 할당 중인 자원의 양

현재 t0일 때 프로세스에 할당된 자원의 합은 5+2+2 = 9 개이다. 현재Availble 자원은 12 - 9 = 3개 이다.

</br>

여기서 Safe sequence를 찾아보니 순서가 P1, P0, P2 일 때 안전 순서를 만족한다. </br>

- P1은 2개가 이미 할당되어 있고, 2개를 추가적으로 할당받기를(Need) 기다리고 있다. 현재 Available 자원은 3개이므로, 이 중에 2개를 P1에게 할당해 준다. => 현재 Available은 3 - 2 = 1개  </br>

- 실행이 끝난 P1은 자신에게 할당되어 있던 자원 4개를 모두 반납한다. => 현재 Available은 1 + 4 = 5개  </br>


- 현재 Available 자원이 5개이고, 이를 P0에게 모두 할당해 주면 P0도 실행 가능해진다. => 현재 Available은 5 - 5 = 0개 가 된다.  </br>

- 실행이 끝난 P0은 자신에게 할당되어 있던 자원 10개를 모두 반납한다. => 현재 Available은 0 + 10 = 10개  </br>

- 마지막으로 P2에게 자원 7개를 할당해 준다. => 현재 Available은 10 - 7 = 3개  </br>

- 실행이 끝난 P2는 자신에게 할당되어 있던 자원 9개를 모두 반납한다. => 현재 Available은 3 + 9 = 12개  </br>

이렇게 자원의 부족함 없이 올바르게 할당하여 모든 프로세스가 실행을 할 수 있다.  </br>


만약 여기에서 P2 프로세스가 처음에 자원을 하나 더 할당받고 있었다면(즉, 2개가 아니라 3개) 운영체제가 가지고 있는 Available 자원은 12 - (5+2+3) = 2개 였을 것이다.  </br>

이 상황에서는 처음에 P1에게 2개를 모두 주고, P1이 실행이 끝나고 자원을 모두 반납해도 Available 자원은 2 + 2 = 4개 뿐이므로, 이 자원으로는 나머지 P0이나 P2 프로세스를 해결해 줄 수 없다. (모두 4개보다 많은 양의 자원을 필요로 하고 있으므로)  </br>

따라서 P0, P2는 자원을 할당받기를 계속 기다려야 할 것이다.  </br>

</br>

운영체제가 사전에 P2 프로세스가 자원을 하나 더 요청했을 때 할당해 주지 않고, P1이 먼저 끄트나게 한다면 데드락이 발생하지 않을 것이다. </br>

그러므로 은행원 알고리즘을 사용해서 자원 할당량을 사전에 파악하고 데드락을 회피할 수 있다. </br>

</br>

### 단점
- 미리 최대 자원 요구량을 알아야 한다.
- 할당할 수 있는 자원수가 일정해야 한다. 
- 항상 불안정 상태를 방지해야 하므로 자원 이용도가 낮다.
- 프로세스들은 유한한 시간 안에 자원을 반납해야한다. 

#### 즉 엄청나게 복잡하다. 해당 프로세스가 시작할 때 프로세스가 가지고 있어야 할 자원의 최대 개수를 미리 알아야 하기 때문에 실제 돌아가는 프로그램에 적용하기 어렵다. 오버해드가 너무 크기때문에 현재 채택하고 있는 방식은 아니다. 


</br></br>

## 3. 데드락 발생을 허용하지만 데드락 탐지(detection)하여, 데드락에서 회복하기
- 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 데드락을 탐지하고 회복하는 알고리즘을 사용한다.

### 1. 탐지 기법
- Alloctation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색한다.
- 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.
- 이외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다.

### 2. 회복 기법
- 데드락을 탐지 기법을 통해 발견했다면, 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법을 사용한다.

### 단순히 프로세스를 1개 이상 중단시키기
- 교착 상태에 빠진 모든 프로세스를 중단시키는 방법: 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있다.

- 프로세스를 하나씩 중단 시킬때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법: 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있다.

### 자원 선점하기
- 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법

</br></br>

## 4. 무시
- 교착상태 자체를 무시하고, 특별한 조치를 취하지 않음 -> 교착상태의 발생 확률이 낮은 상황에서 효율적
- 만약 교착상태가 발생한다면, 프로세스를 종료하거나 자원을 선점하여 회복한다.
- UNIX, Window 등 대부분의 운영체제가 이 방법으로 사용한다.

</br></br>


### 대부분의 운영체제는 교착상태 발생을 무시한다. 실제로 처리하는 프로그램의 작성은 응용 개발자의 책임이다. 

### 예방: 네가지 조건중 하나를 아예 불가능하게 만든 것
### 회피: Deadlock 발생 가능성을 계속 검사해서 안정 상태, 불안정 상태로 나누고 불안정 상태일 경우 Deadlock이 발생할 가능성이 있다 판단해 해당 작업을 아예 피해버린다.

### 식사하는 철학자들 문제(Dining Philosophers)로 보는 Deadlock


</br></br>

=====================================================


## 교착 상태를 공부하면서 헷갈렸던 부분

### 1. 은행원 알고리즘은  교착 상태를 "회피" 하는 방법중 하나인데, 무한정 대기가 들어갈 때 교착 상태인지 기아 상태인지 헷갈렸다.

</br>

은행원 알고리즘이 교착상태를 완전히 예방해주지 않는다. </br>

- 프로세스가 필요로 하는 자원의 수를 미리 알 수 없을 경우
- 자원 요청에 대한 우선순위를 고려하지 않는 경우

</br>

또한, 완전히 교착상태를 회피해도 "자원 할당을 위해 많은 검사가 필요하기 때문에" 시스템 규모나 자원의 수가 많을 수록 성능 저하가 크게 나타날 수 있다.

</br>

은행원 알고리즘에서 자원 할당은 우선순위 기반으로 이루어진다. (위에 예시처럼 순서 정함) </br>

### 따라서 낮은 우선순위 프로세스가 무한정 대기하는 상황이 발생하는 데 이때 "기아 상태"라고 한다. 

### 은행원 알고리즘이 무한정 대기가 들어가게 된다면, 이는 기아 상태일 수 있다. 


## 교착 상태 VS 기아 상태

교착 상태: 여러 프로세스들이 서로가 가진 자원을 점유하고 있는 상황에서, 자원을 반납하지 않고 무한정 기하는 상황 </br>

기아 상태: 프로세스들이 필요로 하는 자원이 계속해서 다른 프로세스에 할당되어, 자원을 받지 못하는 상황

