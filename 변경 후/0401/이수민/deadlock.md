# Deadlock(= 교착상태)

</br>

![image](https://user-images.githubusercontent.com/58407737/229269483-a1b7c792-867f-49d3-af23-07dc673f5ef0.png) </br>


p1이 r1을 가지고 있고, p2는 r2를 가지고 있다. </br>
그러나 p2는 r1이 필요하고, p1는 r2가 필요하는데 서로 필요한 걸 가지고 있지만, 이 요구가 뒤엉킨 상태로 계속 서로가 갖고 있는 자원을 받을 때까지 무한정으로 대기 하게 되는 것이다. </br>
*p1: process 1,  r1: resource 1, p2: process 2, r2: resource 2 </br>


### 즉, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 뜻한다.


</br>

### 생긴 이유? 

초기에 있던 일괄 처리 시스템에서는 교착 상태가 자주 발생하지 않았다. </br>
시스템 효율을 증가시키고 제한된 자원의 사용률을 높이기 위해 사용하는 병행 처리 기술과 자원 공유 기술로 교착상태이라는 부작용이 생긴 것이다.

</br>

순서 : 자원 요청 -> 자원 사용 -> 자원 해제 </br>

이때 자원 요청, 해제는 system call로 한다.  </br>


</br>
</br>

## 발생 조건

### 1. 상호 배제
- 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.
- 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

</br>

### 2. 점유와 대기
- 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다. 

</br>

### 3. 비선점
- 이미 할당된 자원을 강제로 뺴앗을 수 없다. 
- 프로세스가 자원 사용을 마친 후 자원을 되돌려(해제) 한다고 했었는데 이때, 자원을 강제로 뺴앗는 것이 아니라 자원을 점유하고 있는 프로세스가 해당 자원을 되돌려(해제)해야 한다는 것이다. 

</br>

### 4. 순환 대기
![image](https://user-images.githubusercontent.com/58407737/229270726-9df6dc2f-db60-475d-abe1-fced8b895126.png) </br>

- 위의 그림과 같이 대기 프로세스 집합 {P0, P1, ..., Pn }이 있을때 P0은 P1이 보유한 자원을, P1은 P2, Pn-1은 Pn이 보유한 자원을 Pn은 P0이 보유한 자원을 각자 얻으려고 기다리는 것을 순환 대기라 한다. 


</br>

### 4가지 조건을 예시로 표현한 것 
![image](https://user-images.githubusercontent.com/58407737/229270919-288085e5-15b1-48c3-8aa3-f9973b82124d.png) </br>
 
![image](https://user-images.githubusercontent.com/58407737/229270931-d1d19ba0-53aa-41dc-88c1-763c8a9dd38c.png) </br>

</br>

## Deadlock 해결 방안 
### 1. 데드락이 발생하지 않도록 예방(prevention) 하기
- 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

**1. 자원의 상호 배제 조건 방지** </br>
- 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다. -> 동기화 관련 문제 발생 가능성 있음

**2. 점유 대기 조건 방지** </br>
- 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다. </br>

**3. 비선점 조건 방지** </br>
- 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 떄, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.

**4. 순환 대기 조건 방지** </br>
- 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다. 

</br>

이러한 예방 방법은
### 시스템의 처리량이나 효율성을 떨어트리는 단점이 발생할 수 있다.

</br>

그래서, 예방법보다는
### 조건 덜 제한적인 방법으로 예방법의 단점 일부를 해결하는 회피법이 있다.

</br>

### 2. 데드락 발생 가능성을 인정하면서도 적절하게 회피(avoidance) 하기
**Sage squence, Safe state 등이 키워드** </br>

시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 **안정상태(safe state)** 에 있다고 말한다. </br>

그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 **데드락이 발생하지 않는 순서를 찾을 수 있다면**, 그것을 **안전 순서(Safe safe sequence)** 라 한다. </br>

![image](https://user-images.githubusercontent.com/58407737/229272382-f8b0a5dc-ea41-47cf-917d-c76e8b791a8f.png) </br>

반면 **불안정 상태** 는 데드락 발생 가능성이 있는 상황이고, 데드락은 불안정 상태일 때 발성할 수 있다. </br>
불안정 상태가 교착 상태보다 더 큰 집합이다. (즉, 교착 상태가 불안정 상태의 부분집합)

</br>

이처럼 회피 알고리즘은 **자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자** 라는 것이 기본 특징이다.  </br>

이러한 특징을 살린 알고리즘이 **은행원 알고리즘** 이다. 

</br></br>

### 은행원 알고리즘 (Banker's Algorithm)
- 다익스트라가 제안한 기법
- 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사한다.
- 즉, 대기중이던 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것이다.
- 은행원 알고리즘에서 운영체제는 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을떄까지 계속 거절한다. 


### (예시)

![image](https://user-images.githubusercontent.com/58407737/229272900-e0a02028-0c21-4d30-a7c2-7ea3eeaed895.png) </br>

1. 100달러를 가지고 있는 은행이 있고, 돈을 빌려달라는 고객이 3명이 있다. 
2. 고객은 필요한 돈이 다 있어야만 일을 해결할 수 있고 빌린 돈을 상환할 수 있다. (즉, 30달러가 필요하다.20달러만 있으면 상황 해결이 안된다.)
3. 고객 1은 60달러, 고객 2는 40달러, 고객3은 50달러가 필요하다.
4. 은행은 일단 고객1에게 20달러, 고객2와 고객3에게 30달러 빌려줬다.
5. 그러면 20+30+30 = 80달러이며  
6. 100 - 80 = 20은 은행이 수중에 가지고 있는 돈이다.
7. 그런데 아직 고객1은 40달러, 고객2는 10달러, 고객3은 20달러가 추가적으로 필요한 상황이다.

</br>
<




</br>

어떤 자원 한가지에 대해서 은행원 알고리즘 시뮬레이션 해보기 </br>

1. 시스템에 총 12개의 자원을 가지고 있다.
![image](https://user-images.githubusercontent.com/58407737/229272612-ce72513b-94d6-4fdd-ac06-4f65318a36ee.png) </br>

- P0 ~ P2는 프로세스
- Max는 각 프로세스마다 최대 자원 요청량
- Allocation은 현재 프로세스에 할당 중인 자원의 양

현재 t0일 때 프로세스에 할당된 자원의 합은 5+


