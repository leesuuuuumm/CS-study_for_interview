윈도우 운영체제는 가동되고 있는 프로세스들의 내용(페이지) 중, 덜 중요한 것들을 하드 디스크의 공간에 옮겨 놓는다. 
(어디에 저장했는지도 기록해 놓음) </br>

그리고 프로세스가 동작하는 도중, 메모리에 필요한 데이터(페이지)가 없으면 하드디스크를 찾아 해당 데이터를 가져온다.
(속도 저하 발생 -> ROM이 RAM보다 느리기 때문) </br>

![image](https://user-images.githubusercontent.com/58407737/229276525-fac5fea1-77e4-4ccb-8f3f-f8fc7888cfdf.png) </br>

</br>
</br>


# 가상 메모리 (Virtual Memory)?
- RAM을 관리하는 방법 중 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식이다.
- RAM의 부족한 용량을 보완하느나 데 주로 쓰인다.
- 프로세스마다 하나씩 갖고 있는 고유한 공간 

</br>

## 가상 메모리를 사용하면?
1. CPU는 메모리의 실제 주소인 물리주소 대신 가상 주소에 먼저 접근한다.
2. 이때 페이지 테이블을 참조하여 가상 주소를 물리 주소를 변환하여 실제 메모리에 접근하게 되는데 이러한 변환 과정이 굉장히 빈번하게 일어나고 속도가 굉장히 중요하므로 MMU라는 하드웨어 칩의 지원을 받는다. 

</br>

## 물리 메모리
- RAM이라고 말하는 그런 장소에 올려져 있는 것
- 실제 프로그램이 동작하기 위해서는 물리 메모리에 로딩되어 있어야한다. 
- 한정적인 자원을 가지고 있음

</br>

## MMU (Memory Management Unit)?
- CPU가 코드를 실행하여 가상 메모리 주소에 접근할 때 가상 메모리 주소를 실제 물리적인 주소로 변환해주는 하드웨어 장치이다. 

</br>

## Page?
- 가상 메모리를 사용하는 최소 크기 단위
- 가상 메모리 기법을 사용할 때 실제 메모리에 올려놓는 기본 단위가 되는 것
- 페이지 단위로 관리하게 되며 페이지 번호를 바탕으로 가상 메모리 주소와 실제 메모리 주소를 매핑하여 페이지 테이블에 기록하고 관리한다.
- 가상 메모리 주소 = (p, d)로 이루어져있다. </br>
(p: 가상 메모리 페이지, d: distance로 p내 offset을 의미한다.)

</br>

## 가상 메모리 기법의 흐름
- CPU가 명령어를 실행하던 중 가상 메모리 주소를 참조하게 되면 하드웨어 칩셋인 MMU를 거쳐서 실제 메모리에 올라가 있느 페이지 테이블을 참조하여 실질적인 메모리 주소를 변환하게 되고 메모리에 접근하게 된다.
- 메모리에 반복적응로 접근하고 데이터를 읽어오게 되는데 이러한 속도는 CPU나 레지스터 속도에 비해 굉장히 느리다.
- 이런 부분에서 성능 향상을 위해선 TLB라는 하드웨어를 사용하게 된다.


</br>

## TLB(Tranclation Lookaside Buffer)?
- 최근에 접근한 페이지 정보를 기록하는 하드웨어 칩셋이다.
- 즉, 가상 메모리 주소가 한번 물리 주소로 변환되면 TLB에 기록하고 그 다음부턴 MMU가 페이지 테이블을 참조하는 것이 아닌 TLB를 통해 물리 주소를 먼저 찾는다. 
- 이를 통해 상대적으로 속도가 느린 메모리에 접근하는 횟수를 줄여 성능 향상 시켜준다.


</br>

# 페이지 폴트(Page fault)?
- 가상 메모리 주소를 통해 실제 물리 주소를 얻고 메모리에 접근했지만 내가 원하는 페이지가 실제 메모리에 적재되어 있지 않을 수 있다. 
- OS의 스와퍼는 물리 메모리에 동작하고 있는 모든 프로세스를 동작하지 않고
- OS의 페이저는 프로세스의 모든 페이지를 물리메모리에 로드하지 않는다. (물리 메모리를 효율적으로 사용하기 위해)
- 그래서 프로그램의 페이지가 물리 메모리에 부재할 수 있는데 ( 내가 찾는 페이지가 실제 메모리에 적재되어 있지 않을 때) 이를 페이지 폴트라 한다.

</br>

- 페이지 폴트가 발생하면 해당 페이지를 가상 메모리에서 찾아와야한다.
- 이때 운영체제가 페이지 폴트를 해결하는 과정은 요구 페이징(Demand Paging)이라 한다.

</br>

## 요구 페이징(Demand Paging)?
![image](https://user-images.githubusercontent.com/58407737/229278897-3e912fb4-0b01-4ab2-bedc-09f4979a3f99.png) </br>

- 운영체제는 페이지 테이블로 가상 메모리를 관리한다.
- 페이지 테이블에는 각 페이지가 저장되어 있고, 주소값이 들어있다.
- 페이지 테이블에는 Valid bit이 있어, 이를 이용해 해당 페이지가 어느 메모리에 있는지 표시할 수 있다.
- 그러므로 페이지 테이블로 가상 메모리에서 페이지를 수비게 찾을 수 있다.

- 장점: 프로세스 단위가 아닌 페이지 단위이기 때문에 I/O & memory가 적게 들고, 응답이 빠르다.

### 운영체제가 페이지 테이블을 이용해, 요구 페이징을 수행하는 과정

![image](https://user-images.githubusercontent.com/58407737/229279625-2f97a16c-925d-4a9e-ba95-4369f5ad265f.png) </br>

1. CPU는 물리 메모리를 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알린다. </br>
(trap: SW 인터럽트, SW가 시스템 콜이라는 연산을 실행하여 발생시킨다.)

2. 운영체제는 CPU의 동작을 잠시 멈춘다.

3. 운영체제는 page fault handler를 호출해서 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단한다.

4. 페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임이 있는지 찾는다.

5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.

6. 중단되었던 CPU를 다시 시작한다.

</br>

만약 물리 메모리에 비어있는 프레임이 없다면? </br>
- 프로세스를 멈출 수 없으므로 희생 프레임을 골라서 이를 가상 메모리에 저장한 후 필요한 페이지를 물리 메모리에 로드한다.
- 이 과정에서 페이지 교체 알고리즘이 사용된다.

</br>

### 페이지 교체 알고리즘 (Page Replacement Algorithm)
1. FIFO: 가장 먼저 물리 메모리에 적재된 페이지를 선택하는 방식
2. LRU: 가장 오랫동안 사용되지 않았던 page 선택
3. LRU Approximation: LRU와 같지만, 페이지에 Second-Chance를 준다. </br>


</br>

LRU Approximation
- 각 페이지들을 Circular queue형태로 나타낸 후 LRU에 의해 희생페이지가 선택되었을 때 해당하는 queue의 bit가 0이면 해당 페이지를 제거한다. 
- bit가 1이면 0으로 설정한다.

