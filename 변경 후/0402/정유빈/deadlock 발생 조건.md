<h1> 교착상태 </h1>

- 교착 상태란 2개 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며, 서로의 자원이 끝나기만을 기다리며 둘 다 영원히 끝나지 않는 상황을 뜻한다.

<h1> DEADLOCK 발생 조건 </h1>

1. 상호배제(Mutual Exclusion)

- 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있다.

2. 점유대기(Hold and Wait)

- 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.

3. 비선점(No preemption)

- 이미 할당된 자원을 강제로 뺏을 수 없다.
- 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없다.

4. 순환대기(Circular wait)

- 각 프로세스는 순환적으로 다음 프로세스가 요구되는 자원을 가지고 있다.

<h1> 교착상태 해결 방법 </h1>

- 교착상태는 위 4가지 조건을 모두 만족할 때 발생한다.
- 교착 상태의 해결법을 크게 3가지로 분류할 수 있다.
- 1. 데드락이 발생하지 않도록 <b> 예방(prevention) </b> 하기
- 2. 데드락 발생 가능성을 인정하면서도 적절하게 <b> 회피(avoidance) </b> 하기
- 3. 데드락 발생을 허용하지만 데드락을 <b> 탐지 (detection) </b> 하여, 데드락에서 회복하기


<h1> 교착상태의 예방 </h1>

- 대부분의 접근들은 4개중 하나를 막음으로써 동작하며, 특히 4번째 것을 막음으로서 동작한다.
- 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

1.  상호배제 조건의 제거

- 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
- 그러나 추후 동기화 관련 문제가 발생할 수 있다.

2. 점유와 대기 조건 제거

- 한 프로세스에 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을 때는 다른 프로세스가 자원을 요구하도록 하는 방법이다.

3. 비선점 조건의 제거

- 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
- 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다.

4. 순환 대기 조건의 제거

- 자원 유형에 따라 순서를 매긴다.
- 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.

- 위 교착 상태들의 해결 방법은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있다.
- 교착 상태의 회피법은 예방법보다는 <b> 조금 덜 제한적인 방법 </b> 으로 예방법의 단점을 일부 해결할 수 있다..

<h1> 교착 상태의 회피 </h1>

- 데드락 회피법에서는 <b> Safe sequence, Safe state </b> 등이 키워드이다.
- 시스템의 프로세스들이 요청하는 모드 자원을, 데드락을 발생시키지 않으면서도 차레로 모두에게 할당해 줄 수 있다면 <b> 안정 상태 (safe state) </b> 에 있다고 말합니다.
- 그리고 이처럼 특정한 순서로 프로세스에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 <b> 데드락이 발생하지 않는 순서를 찾을 수 있다면, </b> 그것을 <b> 안전 순서(safe sequence) </b> 라고 부른다.
- 반면 <b> 불안정 상태 </b> 는 안전 상태가 아닌 상황을 말한다.
- 즉, <b> 데드락 발생 가능성이 있는 상황 </b> 이며, <b> 교착 상태(데드락)는 불안정 상태일 때 발생 </b> 할 수 있습니다.
- 불안정 상태가 교착 상태보다 좀 더 큰 집합입니다. (즉, 교착 상태가 불안정 상태의 부분집합)
- 이처럼 회피 알고리즘은 <b> 자원을 할당한 후에도 시슽메이 항상 Safe state에 있을 수 있도록 할당을 허용 </b> 하자는 것이 기본 특징이다.

- 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것으로, 시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다.

- 교착 상태 회피하기 위한 알고리즘으로 크게 2가지가 있다.
- 1) 자원 할당 그래프 알고리즘
- 2) 은행원 알고리즘

<h1> 은행원 알고리즘(Banker's Algorithm) </h1>

- 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, <b> 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션해서 Safe State에 들 수 있는지 여부 </b>를 검사한다.
- 즉, 대기 중인 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것이다.
- 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구를 충족할 수 있도록 현금을 대출해주는 것에서 유래했다.
- 은행원 알고리즘은 자원 할당 결정 전에 예상되는 모든 자원의 최대 할당량을 가지고 시뮬레이션을 하여 safe state에 들 수 있는지 여부를 검사하여 교착 상태의 가능성을 미리 조사하는 알고리즘이다.
- 기본 개념 자체는 <b> "CPU는 최소한 하나의 프로세스에게 할당해줄 만큼의 자원을 항상 보유하고 있어야 한다. </b> 입니다.

</br>

<예시> 시스템은 총 12개의 자원을 가지고 있다고 가정 </br>

![image](https://user-images.githubusercontent.com/62228401/229319291-ea67e739-7655-49aa-8e41-d74e82e5205f.png)

<br />

- 현재 할당 중인 자원량의 합은 <b> 5 + 2 + 2 = 9 </b> 입니다.
- 시스템은 총 12개의 자원을 가지고 있으므로 현재 상태에서 가용 자원량은 <b> 12 - 9 = 3 </b> 이 됩니다.
- 여기서 가용 자원을 어느 프로세스에게 할당해주느냐에 따라서 자원을 효율적으로 이용할 수 있게 됩니다.
<br />

- 남은 가용자원 3개를 P1에게 할당 => <b> 가용 자원은 3 - 2 = 1 </b>
- P1의 작업이 끝나고 할당되어 있던 자원 4개 반납 => <b> 가용 자원은 1 + 4 = 5 </b>
- 남은 가용 자원 5개를 p0에게 할당 => <b> 가용 자원은 5 - 5 = 0 </b>
- p0의 작업이 끝나고 할당되어 있던 자원 10개 반납 => <b> 가용 자원은 0 + 10 = 10 </b>
- 남은 가용 자원 10개 중 7개를 p2에게 할당 => <b> 가용 자원은 10 - 7 = 3 </b>
- p2의 작업이 끝나고 할당되어 있던 자원 9개 반납 => <b> 가용 자원은 3 + 9 = 12 </b>

<br> 

이렇게 P1 - P0 - P2 순서로 자원 할당 시 Safe Sequence를 만족하게 된다. </br>

- 그러나 은행원 알고리즘의 경우 미리 자원의 최대 요구량을 알아야 하고, 핟당할 수 있는 자원의 수가 일정해야 하는 등 사용에 제약조건이 많다
- 이처럼 교착상태 회피 방법의 가장 큰 문제는 <u> 문제 발생에 대한 일관성과 가정이 완벽할 것이라는 것을 보장하기가 현실적으로 어렵다는 점</u> 입니다. 시스템의 규모가 작은 운영체제라면 고려해볼 만한 방법이지만, 멀티 리소스, 멀티 프로세스의 복잡한 운영체제 환경에서는 자원 할당 그래프를 분석하면서 Safe state를 파악하기가 상당히 어렵다.


<h1> 탐지 </h1>

- 말 그대로 시스템에 deadlock이 발생했는지에 대한 여부를 탐색하고 회복 기법 알고리즘에 활용하는 것을 의미한다.
- 교착상태가 탐지되었다면 회복 기법을 통해 교착상태를 복구한다.
- 그러나 탐지 기법은 지속적으로 교착 상태를 확인하는 작업이 필요하기 때문에 오버헤드(성능 저하)가 발생하게 됩니다.
<h1> 회복 </h1>

- 교착 상태가 발생했을 때 해결하는 기법

1. 사용자 처리

- 교착 상태에 있는 프로세스 중 하나의 프로세스를 사용자가 강제 종료

2. 시스템 처리

    1. 프로세스 중지
  
      - 교착 상태에 속해있는 모든 프로세스를 중지
      - 교착 상태가 해결될 때까지 한 프로세스를 중지

    2. 자원 선점

      - 프로세스들로부터 자원을 빼앗아 교착 상태가 해결될 때까지 다른 프로세스들에게 자원을 할당
