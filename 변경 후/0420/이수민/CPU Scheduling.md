</br>

# 프로세스 상태 전이
- 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 준비, 실행, 대기-블록 등의 여러가지로 변화하는 것 
</br>

![image](https://user-images.githubusercontent.com/58407737/233103294-cf3279ca-0f2c-418e-80b1-31874ccfe6e1.png) </br>
![제목을-입력해주세요_-001 (3)](https://user-images.githubusercontent.com/58407737/233117178-93eb2fcd-1025-4050-9ac0-0603776a637d.png) </br>
![image](https://user-images.githubusercontent.com/58407737/233232001-4fe54823-9949-4504-ad54-a97b5e62868f.png)


## [프로세스 상태] 
## 활성 상태 

### 생성
- 프로세스가 생성되고 나서 생성된 프로세스는 준비(Ready) 상태에 머문다.
- 준비 상태는 CPU를 점유하고 있는 상태가 아니라, CPU를 점유하길 희망하는 상태다.
- 준비 상태에서 실행 상태로 넘어가려면 작업 스케줄러가 선택 주어야만 한다.
- 주기억장치에 적재되지 않고 보조 기억 장치에 저장되어 있는 실행 파일 형태이다.

### 준비
- 프로세스가 CPU를 사용하여 실행 준비 된 상태이다.
- 프로세스 상태 리스트 중 준비 리스트에 들어간다.
- 프로세스가 우선순위에 의해 정렬된다. 
- CPU 스케줄러가 어떤 프로세스에게 CPU 제어권을 넘겨줄지 고른다.
- 운영체제 안에서 CPU 스케줄링을 하는 코드가 있는데, 그 부분을 CPU 스케줄러라고 부른다.

### 실행
- 프로세스가 CPU를 차지하여 실행중인 상태이다.
- 명령어들이 실행되고 있는 상태이다. 

### 대기
- 기다림 또는 블록 상태이다.
- I/O 동작의 완료 등 사건 발생을 기다리는 상태이다.
- 프로세스 상태 리스트 중 블록 리스트에 들어간다.

### 종료
- 프로세스 실행이 완료되어 자원을 반납한 상태이다.
- 프로세스가 종료되어 사용했던 데이터를 삭제하고 PCB를 폐기한다.
- 활성 상태에 있는 프로세스는 메모리에는 올라와 있으며 실행이 되고 있거나 잠시 멈춘 상태이다.

## 보류 상태
- 프로세스는 메모리에 적재되어 있지 않으며, 일시 정지 상태라고 부른다.
- 메모리에서 쫓겨 난 프로세스는 Swap 영역에 보관된다.



## [프로세스 상태 전이]
CPU를 차지하며 Running 상태였던 프로세스가 나가고 새로운 프로세스가 Running 상태가 되는 작업이다. </br>
이때, 각 프로세스의 PCB가 변경된다. </br>
-> 즉, 실행 상태에서 나가는 프로세스의 PCB는 작업 내용을 저장하며, 실행 상태로 들어오는 프로세스는 PCB 내용을 바탕으로  CPU가 세팅된다.
</br>

- Running -> Ready: 실행 중이던 프로세스가 작업 시간을 다 사용해 timeout이 발생하면 준비 상태로 옮긴다.
- Running -> End: 실행 중이던 프로세스가 작업 시간 안에 작업을 끝내면 종료 상태로 옮긴다.
- Running -> Waiting: 실행중이던 프로세스가 입출력을 요청하면 대기 상태로 옮긴다.
- Wating -> Interrupt -> Ready: 입출력을 요청하여 대기 상태에 있던 프로세스의 요청이 완료되면 Interrupt가 발생해 해당 프로세스를 깨워서 준비 상태로 옮긴다. 
즉, Context Switching은 하드웨어를 통한 I/O 요청이나 CPU 스케줄링에 의한 Interrupt에 의해 발생한다.

![image](https://user-images.githubusercontent.com/58407737/233236787-eece4396-22f7-4b52-b485-be4e12d360ec.png)





## CPU - I/O 버스트 사이클 (CPU - I/O Burst Cycle)
- 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다.
- CPU Burst로 시작되고, I/O Burst가 발생하고, 그 뒤를 이어 또 다른 CPU Burst가 발생하는 등등으로 진행된다.
- 그림처럼 마지막 CPU Burst는 실행을 종료하기 위한 시스템 요청과 함께 끝난다. 
- CPU Burst: CPU 명령을 실행하는 것 / I/O Burst: I/O를 요청한 다음 기다리는 시간
</br>

![image](https://user-images.githubusercontent.com/58407737/233099414-8abe5b09-f694-45e7-a209-d60d35728d00.png)

</br>
</br>

## 프로세스 Scheduling
- 프로세스가 생성되어 실행될 때 필요한 순서와 시간을 결정하여 해당 프로세스에 할당하는 작업이다. 
 
### Job Scheduling: 어떤 프로세스가 시스템의 자원을 사용할 수 있는지 결정하여 준비 상태 큐로 보내는 잡업
### Process Scheduler: 하나의 프로세스를 준비 상태에서 실행 상태로 전이시키는 것을 의미 


# CPU Scheduling?
- 작업을 처리하기 위해서 프로세스들에게 CPU를 할당하기 위한 정책을 계획하는 것
- 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 것이다.

</br>

### 필요한 이유?
CPU Bound Job 문제가 아닌 I/O Bound Job 때문이다. I/O Bound Job은 일반적으로 사람과 Interaction을 하는 작업이기 때문이다. </br>
CPU bound job이 CPU를 잡고 놓지 않으면 I/O Bound job은 CPU를 잡지 못하고 오래 기다리게 되기 때문에 사용자 입장에서 매우 답답하다. </br>
CPU를 공평하게 주는 것도 좋지만 Intercation을 하는 job에게 적절하고 빠른 응답을 제공하기 위해서 CPU를 더 우선적으로 주는 것도 필요하기 때문에 CPU 스케줄링이 중요하다.</br>

- I/O Bound Process: I/O 작업이 많기 때문에 CPU Burst는 빈번하지만 짧아진다.
(CPU를 잡고 계산하는 시간보다 I/O에 시간이 많이 필요한 Job)

- CPU Bound Process: I/O 작업이 많이 없기 때문에 CPU를 지속적으로 쓰는 작업이 길어진다. (CPU Burst 시간이 긴 작업)
(계산위주의 Job)

</br>

## 스케줄링 기준
- 여러 CPU 스케줄링 알고리즘에서 하나를 선택하기 위한 CPU 스케줄링 비교 기준이다.

### CPU 이용률(Utilization)
- 어느 기간 동안 특정 SNAPSHOT에서의 CPU의 이용률을 말한다.
- CPU가 쉬지 않고 얼마나(40~90%) 이용하는지에 대한 기준(많을수록 양호)

### 처리량(Troughput)
- 단위 시간당 완료된 프로세스의 개수로써 나타낼 수 있다.
- 단위 시간당 처리할 수 있는 CPU 작업량이 얼마나 많은가 하는 기준(많을수록 양호)

### 대기 시간(Waiting time)
- 대기 시간은 프로세스가 준비 큐에서 대기하면서 보낸 시간의 합이다.
- 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간, 즉 준비 상태에서 대기하는 시간이 얼마인가 하는 기준(짧수록 양호)

### 총처리 시간(=반환시간, Turnaround Time)
- 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다.
- 각 프로세스가 생성된 시점(준비 큐에 들어온 시점 동일하다고 가정)부터 수행이 완료된 시간, 즉 작업을 지시해서 작업이 끝날 때까지 시간이 얼마인가 하는 기준(짧을수록 양호)

### 응답 시간(Response Time)
- 하나의 Request를 제출한 후 첫 번째 Response가 나올 때까지의 시간이다.
- 입력에 대해 처음 반응하는 시간이 얼마인가 하는 기준(짧을수록 양호)

</br>



</br>

![image](https://user-images.githubusercontent.com/58407737/233099926-8f07c3f3-2838-4549-97e4-fd81694af31d.png)

</br>

- CPU가 **유휴 상태(사용가능한 상태이나, 실제적인 작업이 없을 때)** 가 될 때마다, OS는 ReadyQueue에 있는 프로세스 중에서 하나를 선택해 실행한다.
- 선택 절차는 CPU 스케줄러에 의해 수행된다. 
- CPU 스케쥴링 대상 프로세스는 Ready Queue에 있는 프로세스들로, 스케줄링 정책에 따라 Queue에 정렬을 한 후 앞에 있는 프로세스 부터 CPU를 주게 된다. 
- CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.
- ReadyQueue는 반드시 FIFO 방식이 아니어도 되고, 우선순위 큐, 트리 등으로 구현될 수 있다. (일반적으로 큐에 있는 레코드들은 프로세스의 PCB 블록들이다.

 </br>
 
# CPU 스케줄링이 필요한 경우 (프로세스의 상태변화 별)

## 자진반납(비선점, = Nonpreemptive)
### 1) Running -> Blocked
- CPU를 쓰다가 오래 걸리는 작업(I/O 등)이 있어 Blocked 되는 경우 (CPU가 있어도 사용하지 못하는 상황)
- 다른 프로세스에게 CPU를 주기 위해 

### 2) Terminated
- 프로세스가 종료되었을 때 CPU를 누구에게 줄지 고려해야한다.


## 강제로 빼앗김(선점, preemptive)

### 1) Running -> Ready
- CPU를 쓰고 싶은데 빼앗겨서 Ready로 돌아가는 경우이다.
- 한 프로세스만 오래 CPU를 사용하면 응답 시간이 길어진다.
- 따라서 다른 프로세스에게 CPU를 주기 위해 timer interrupt를 사용해서 강제적으로 빼앗는 경우이다.

### 2) Blocked -> Ready
- I/O 작업을 하던 프로세스가 작업이 끝난 경우 CPU를 얻을 수 있는 권한이 있는 Ready가 된다.
- 만약 이프로세스가 우선순위가 매우 높다면 I/O가 끝나자마자 CPU를 얻게 될 수 있다.




## 선점 및 비선점 스케쥴링 
-  CPU 스케줄링의 결정은 4가지 상황에 따라 발생한다.
### 1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)
### 2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
### 3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)
### 4. 프로세스가 종료할 때

## 비선점 스케줄링: CPU가 한 프로세스에서 할당되면 프로세스가 종료하든지, 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.(1, 4 해당)

- 모든 프로세스에 대한 요구를 공정하게 처리할 수 있지만, 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기해야할 수있다.
- 처리시간 편차가 적은 특정 프로세스에 용이

</br>

### 우선순위(Priority)
![image](https://user-images.githubusercontent.com/58407737/233246379-9b9bf399-0b60-4ee0-b8fc-d2fdbdbc9205.png) </br>

- 각 프로세스 별로 우선순위가 주어지고, 우선순위에 따라 CPU를 할당한다.
- 우선 순위가 같을 경우 FCFS로 처리한다.
- 설정, 자원 상황 등에 따른 우선순위를 선정해 주요/긴급 프로세스에 대한 우선처리가 가능하다.
- 위 알고리즘의 문제점을 해결할 수 있는 방법은 우선순위 스케줄링 + RR 스케줄링, Aging기법 사용해 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.

</br>

### 기한부(Deadline)
- 작업들이 명시된 기간이나 기한 내에 완료되도록 계획
- 각 프로세스마다 끝내야 하는 기간과 그에 따른 이익이 명시돼있고, 이익을 최대로 할 수 있는 알고리즘 사용해서 구현한다.

</br>

### FCFS (First Come First Served)/ FIFO (First In First Out)
![image](https://user-images.githubusercontent.com/58407737/233246954-7caf666b-3550-4e72-9f56-187931fad78b.png) </br>

- 프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당한다.

</br>

### SJF (Shortest Job First)
![image](https://user-images.githubusercontent.com/58407737/233247043-b3a9de7f-9856-4aeb-bfd4-73d97bd54ac7.png) </br>

- 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원을 선점
- 준비 큐 작업 중 가장 짧은 작업부터 수행하므로 평균 대기시간이 최소
- CPU 요구시간이 긴 작업과 짧은 작업 간의 불평등이 심하여, CPU 요구시간이 길면 기아 현상 발생

</br>

### HRN (Highest Response Ratio Next)
- 대기 중인 프로세스 중 현재 Response Ratio가 가장 높은 것을 선택 (대기시간 + 서비스시간 / 서비스시간)
- SJF와 Aging기법을 합쳐 SJF의 약점인 기아 현산을 보완하는 기법

</br>

## 선점 스케줄링: 시분할 시스켐에서 타임 슬라이스가 소진되거나, 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, 현 프로세스로부터 강제로 CPU 회수하는 것이다. (2, 3 해당)

</br>

### 라운드 로빈 (Round Robin / RR)
![image](https://user-images.githubusercontent.com/58407737/233239256-3db67355-b431-4899-9222-0e5dd15d220c.png) </br>

- 프로세스마다 같은 크기의 CPU 시간을 할당 (시간 할당량 / Time Slice / Quantum) - 보통 10 ~ 100ms 정도
- 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어감
- 균등한 CPU 점유를 보장하며, 시분할 시스템을 사용
*시분할 시스템: CPU 스케줄링과 다중 프로그래밍을 이용해서 각 사용자들에게 컴퓨터 자원을 시간적으로 분할하여 사용할 수 있게 해주는 대화식 시스템

</br>

### SRT (Shortest Remaining Time First)
![image](https://user-images.githubusercontent.com/58407737/233239611-eda09b60-d519-4c26-9d5d-8a647c8421ac.png) </br>

- 가장 짧은 시간이 소요되는 프로세스를 먼저 수행
- 남은 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점 됨


</br>

### 다단계 큐 (Multi Level Queue)
![image](https://user-images.githubusercontent.com/58407737/233240088-12f47ede-f04e-4e1f-9597-cc1302a7456a.png) </br>

- 작업들을 여러 종류 그룹으로 분할, 여러 개의 큐를 이용하여 상위 단계 작업이 선점
- 각 큐는 자신만의 독자적인 스케줄링을 가짐
- 우선순위 스케줄링과 라운드 로빈이 결합한 스케줄링 알고리즘이다.
- 우선순위를 가진 큐 별로 CPU를 선점할 수 있고, 큐들 사이에 CPU의 시간을 나누어서 사용할 수 있다.

</br>

### 다단계 피드백 큐 (Multilevel Feedback Queue Scheduling)
![image](https://user-images.githubusercontent.com/58407737/233241397-b137ca04-f844-4c09-ae07-b3b329a23731.png) </br>

- 다단계 큐는 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당 된다. 이와 반대로 다단계 피드백 큐는 프로세스가 큐들 사이를 이동하는 것을 허용한다. 
- 각 큐마다 시간 할당량이 존재하며, 낮은 큐일수록 시간 할당량이 커진다.
- CPU Burst는 낮은 우선순위 큐, I/O Burst는 높은 우선순위 큐에 배치한다.
- 가장 하위 큐는 FCFS 스케줄링
- 맨 아래 큐에서 너무 오래 대기하면 다시 상위 큐로 이동(-> 이때 에이징 기법을 사용해 기아상태 예방한다)
- 특정 시스템에 부합하도록 구성이 가능함으로 현대 사용되는 CPU 스케줄링 알고리즘 중 가장 일반적인 CPU 스케줄링 알고리즘이다.
- 모든 매개변수 값들을 선정하는 특정 방법이 필요하기 때문에 가장 복잡한 알고리즘이다.

</br>

#### MFQ 스케줄링에 비해 MLQ 스케줄링은 스케줄링 부담이 적지만 유연성이 떨어지고, 기아현상이 발생할 수 있다.

</br>

# CPU Scheduler VS Dispatcher

### CPU Scheduler: CPU 제어권을 누구에게 줄 것인가
- Ready 상태의 프로세스 중에서 이번에는 어떤 프로세스에게 CPU 제어권을 넘겨줄지 고른다.

### Dispatcher: CPU를 누구한테 줄 지 결정했으니, 그 프로세스에게 CPU를 넘겨주는 역할을 하는 운영체제 커널 코드
- CPU 제어권을 CPU 스케줄러에 의해 선택된 프로세스에게 넘긴다.
-> 이과정을 Context Switch(문맥 교환)

</br>

스케줄러에는 멀티 프로그래밍에 이용되는 long-tern 스케줄러와 CPU 스케줄링에 이용되는 Short-tern 스케줄러가 있다. </br>

#### 스케줄링 (Ready Queue 정렬) + Dispatch (프로세스를 CPU에 올림)

### Context Switch(문맥 교환): 현재 수행 중인 프로세스의 상태 정보를 PCB에 저장하고, 다음 수행할 프로세스의 PCB에서 정보를 읽어와 CPU 레지스터를 세팅하는 과정이다.

#### 필요 이유?
CPU는 한번에 하나의 프로세스만 수행할 수 있지만, 실생활에서는 우리는 여러 개의 프로세스를 동시에 수행하고자 한다. </br>
따라서 CPU는 여러개의 프로세스를 번갈아가면서 수행함으로써 동시에 수행하는 것처럼 보이기 위해 Context Switching을 사용한다. </br>
