### 프로그램을 실행할 때, 컴퓨터는 프로그램들을 메모리 공간에 연속적으로 할당하게 된다. </br>

### 만약 여러 프로그램이 메모리에 할당되고 해제되늰 것이 반복되다 보면 메모리 공간이 조각조각 나뉘게 되어 총 메모리가 충분함에도 불구하고 프로그램에 메모리를 할당하는 것이 불가능한 상태가 된다. </br>

### 이러한 현상을 메모리 단편화라고 한다 </br>

### 메모리 단편화 해결 방법인 페이징, 세그먼테이션이 있다. </br>

</br>

### 페이징과 세그멘테이션을 왜 사용하는 가?
- 프로그램을 실행하기 위해 코드를 디스크에서 메인 메모리로 적재하는 과정에서 단편화가 생길 수 밖에 없다. 
이렇게 단편화가 많이 발생하면서 사용하지 못하는 메모리 공간이 많아져 낭비가 되므로 최대한 피해야한다. 최초 적합, 최적 적합, 압축 등의 방식을 통해 단편화를 해결할 수 있지만, 메모리 계산의 비용이 적은 페이징과 세그멘테이션을 사용한다. </br>


#


# 메모리 관리 기법

## 1. 연속 메모리 기법
- 프로그램 전체가 메모리(하나의 커다란 공간)에 연속적으로 할당된다.
- 고정 분할 기법: 메모리가 고정된 파티션으로 분할되어 **내부 단편화 발생** 한다.
- 동적 분할 기법: 파티션들이 동적으로 생성되고 자신의 크기와 같은 파티션에 메모리 할당을 한다. -> 외부 단편화 발생
#### 파티션: 가상의 벽을 치는 것
- 방이라고 생각하면 된다.
- 하나의 집(하드 디스크) 여러개의 방(파티션)을 만든다.

-> 단편화가 발생한다.


</br>

### 단편화

### 1. 내부 단편화 
![image](https://user-images.githubusercontent.com/58407737/233265159-983832d0-d1d0-4db9-8f9d-b10fd73fc647.png) </br>

- 프로세스가 사용하는 메모리 공간에 남는 부분
- 프로세스가 요청한 양보다 더 많은 메모리 공간에 할당할 때 발생하며, 메모리 분할 자유 공간과 프로세스가 사용하는 공간의 크기 차이를 의미한다.

</br>

### 2.외부 단편화
![image](https://user-images.githubusercontent.com/58407737/233265608-4c5e5911-500c-4fe7-a89c-44fa8b414648.png) </br>
- 메모리 공간 중 사용하지 못하게 되는 부분이다.
- 메모리 할당 및 해제 작업의 반복으로 작은 메모리 공간이 중간중간 존재할 수 있다. 이렇게 사용하지 않는 메모리가 존재해 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황이다.
- 외부 단편화를 해결하기 위해 압축을 이용하여 프로세스가 사용하는 공간을 한쪽으로 몰 수 있지만, 작업 효율이 좋진 않다.

(예) </br>
메모리는 100MB가 들어갈 수 있는데 50, 50 이렇게 나누어져 있음
70MB인 작업이 들어가려고 해도 들어가지 못하는 상황이다.
즉, 작업보다 많은 공간이 남아 있지만 실제로 그 작업을 받아 들이지 못하는 경우이다.

</br>

## 2. 불연속 메모리 기법
- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법이다.
- 외부 단편화를 해소하는 페이징과 내부 단편화를 해소하는 세그먼테이션으로 나뉜다.

# 페이징(Paging) 
 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식이다.
- 페이지: 고정 사이즈의 가상 메모리 내 프로세스 조각
- 프레임: 페이지 크기와 같은 주 기억 장치의 메모리 조각
</br>

- 메모리는 Frame이라는 고정크기로 분할되고, 프로세스는 Page라는 고정크기로 분할된다. (프레임 크기 = 페이지 크기)

- 페이지와 프레임을 대응시키는 Page mapping 과정이 필요하여 paing table을 생성해야 한다.
- 연속적이 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제 해결



### 페이징 테이블
![image](https://user-images.githubusercontent.com/58407737/233266889-509714cb-6372-4e5a-8ad4-62f334d7fa24.png) </br>
- 물리 메모리는 고정된 크기의 프레임으로, 가상 메모리는 고정 크기의 페이지로 분리 되어있다.
- 즉, 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인 메모리의 시작 주소가 있다.


![image](https://user-images.githubusercontent.com/58407737/233267534-c5d0dd29-f2b0-493f-932e-5a45c4249e08.png) </br>

- 메모리 관리 장치 (MMU)는 가상 주소(논리 주소)를 이용해 실제 데이터가 담겨 있는 주소로 변환해준다.

### 장점
- 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요 없으며, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화 X

### 단점
- 내부 단편화 문제가 발생할 수 있다.
- 페이지 단위를 작게하면 해결 할 수 있지만, 페이지 매핑 과정이 복잡해져 오히려 비효율적이다.

</br>

# 세그멘테이션(Segmentation)

- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의마한다.
- 세그멘테이션은 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해 메모리에 적재하는 방식이다.
- 각 세그먼트를 연속적인 공간에 저장한다.
- 세그먼트의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
- 페이징과 마찬가지로 mapping을 위한 segment table가 필요하다.
</br>

(ex) </br>
돼지를 도축할 때, 페이징은 돼지를 같은 크기로 잘라서 보관하는 것이라면, 세그멘테이션은 부위 별로 잘라서 보관한다. </br>


### 세그먼트 테이블
- 분할 방식을 제외하면 페이징과 세그멘테이션이 동일하기 때문에 매핑 테이블의 동작 방식도 동일하다.
- 다만, 논리 주소의 앞 비트들은 페이징 번호가 아니라 세그먼트 번호가 될 것이다.
- 논리 주소가 <segment-number, offset>로 이루어져 있다.
- 세그먼트는 크기가 일정하지 않기 때문에, 테이블에 limit 정보를 추가로 가지고 있다는 점이다.
- 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 해당 프로세스는 강제 종료된다. 

![image](https://user-images.githubusercontent.com/58407737/233270571-ac34b543-fc6a-409e-9847-e15bbd5566a4.png) </br>


- 위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. </br>

- 물리주소 a는 base[s] + d로 계산된다. 
- 논리주소는 v = (s,d)로 표현된다.
- 테이블 내용: base + limit (시작위치, 한계값)
</br>

- 논리 주소 (2,100) => 물리 주소 4400번지라는 
base[2] + 100 = 4400이다.
-> 4300 ~ 4700 까지 이므로 괜찮다.

- 논리 주소 (1,500) => 물리 주소 68000??
base[2] + 500 = 6800이다.
-> 6300 ~ 6700까지 가능한데 세그먼트 크기를 초과하는 주소가 들어왔으므로 인터럽트가 발생해 해당 프로세스는 강제종료 된다.

</br>

### 장점
- 내부 단편화 문제 해소된다.
- 보호와 공유 기능을 수행할 수 있다.
- 프로그램의 중요한 부분과 중요하지 않는 부분들을 분리해서 저장할 수 있고, 같은 코드 영역은 한 번에 저장할 수 있다.

### 단점
외부 단편화 발생
- 크기가 각각 다른 세그먼트를 메모리에 두기 위해서 동적 메모리 할당을 해야한다.
- 이렇게 되면 메모리를 해체, 할당 하는 과정에서 불규칙한 holde이 생겨 외부 단편화가 발생할 수 있음
- 메모리 낭비가 매우 큼

</br>

# 세그멘테이선과 페이징
- 세그멘테이션은 페이징과 유사하고 보호와 공유 측면에서는 더 나은 성능을 보여주고있지만, 현재 대부분은 페이징 기법을 사용한다.

### 이유?
세그멘테이션은 치명적인 단점이 있다.

- 메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다.
- 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다

세그멘테에션도 똑같은 문제점이 발생한다.
- 논리적 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다.

</br>

결론적으로, 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. </br>

두 장점을 합쳐서 사용하는 방법인 세그먼트를 페이징 기법으로 나누는 것이다. </br> 
-> 세그먼트와 페이지가 동시에 존재해서 주소 변환도 두 번해야한다. </br>

즉, CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다. 






