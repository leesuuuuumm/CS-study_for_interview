<h1> 시작하기에 앞서 </h1>

- Block과 non-block, sync과 async 개념을 이해하기 위해서는 다음의 두 용어를 짚고 넘어가야 한다.

- 제어권
  - 제어권은 자신(함수)의 코드를 실행할 권리 같은 것이다.
  - 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.

- 결과 값을 기다리는 것
  - A 함수에서 B 함수를 호출했을 때, A 함수가 B 함수의 결과값을 기다리느냐의 여부를 의미한다.

<h1> 2. Blocking(블로킹)과 Non-blocking(논블로킹) </h1>

<h3> 1) 블로킹 </h3>

- 블로킹과 논블로킹은 A함수가 B함수를 호출했을 때, <b> 제어권을 A가 호출한 B 함수에 넘겨준다. </b>

![image](https://user-images.githubusercontent.com/62228401/233754415-7a1336a1-4f18-48ae-a5be-f83f9858980f.png)

1. A함수가 B함수를 호출하면 B에게 제어권을 넘긴다.
2. 제어권을 넘겨받은 B는 열심히 함수를 실행한다. A는 B에게 제어권을 넘겨주었기 때문에 함수 실행을 잠시 멈춘다.
3. B함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.

<h3> 2) 논블로킹 </h3>

- 논블로킹은 A함수가 B함수를 호출해도 <b> 제어권은 그대로 자신이 가지고 있는다. </b>

![image](https://user-images.githubusercontent.com/62228401/233754561-f57c9812-8352-4454-8204-ed701c290b4b.png)

1. A함수가 B함수를 호출하면, B함수를 실행되지만, <b> 제어권은 A함수가 그대로 가지고 있는다. </b>
2. A함수는 계속 제어권을 가지고 있기 때문에 B함수를 호출한 이후에도 자신의 코드를 계속 실행한다.

<h1> 3. Synchronous(동기)와 Asynchrononus(비동기) </h1>

- 동기와 비동기의 차이는 <b> 호출되는 함수의 작업 완료 여부를 신경쓰는지의 여부 </b>의 차이이다.

<h3> 1) 동기 </h3>

- 함수 A가 함수 B를 호출한 뒤, <b> 함수 B의 리턴 값을 계속 확인하면서 신경쓰는 것</b>이 동기이다.

<h3> 2) 비동기 </h3>

- 함수 A가 함수 B를 호출할 때 <b> 콜백 함수를 함께 전달</b> 해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.
- 함수 A는 함수 B를 호출한 후로 <b> 함수 B의 작업 완료 여부에는 신경쓰지 않는다. </b>

<h1> 4. 블로킹과 논블로킹, 동기와 비동기 비교 </h1>

<h3> 1) Sync-Blocking </h3>

- 동기를 블로킹처럼 실행하는 것은 이해하기 쉽다.

![image](https://user-images.githubusercontent.com/62228401/233754896-1cc04f60-1973-4228-9312-a640de3d4674.png)

- 함수 A는 함수 B의 리턴 값을 필요로 한다.(<b>동기</b>)
- 그래서 제어권을 함수 B에게 넘겨주고, 함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 기다린다. (<b>블로킹</b>)

<h3> 2) Sync-Nonblocking </h3>

- 그런데, 동기를 논블로킹처럼 작동시킬 수 있다.

![image](https://user-images.githubusercontent.com/62228401/233754972-ee80ae4b-8cdf-46c8-8326-600f4d2e972a.png)

- A함수는 B함수를 호출한다.
- 이 때 <b> A함수는 B 함수에게 제어권을 주지 않고, </b> 자신의 코드를 계속 실행한다. (<b>블로킹</b>)
- 그런데, <b> A함수는 B함수의 리턴값이 필요하기 때문에, </b> 중간 중간 B함수에게 함수 실행을 완료했는지 물어본다.(<b>동기</b>)
- 즉, 논블로킹인 동시에 동기인 것이다.

<h3> 3) Async-Nonblocking </h3>

- 비동기 논블로킹은 이해하기 쉽다.
- A함수는 B함수를 호출한다.
- 이 때 제어권을 B함수에 주지 않고, 자신이 계속 가지고 있는다. (<b>논블로킹</b>)
- 따라서 B함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행한다.
- 그리고 B함수를 호출할 때 <b> 콜백 함수</b>를 함께 준다.
- B함수는 자신의 작업이 끝나면 A함수가 준 콜백 함수를 실행한다. (<b>비동기</b>)

![image](https://user-images.githubusercontent.com/62228401/233755266-41909785-f6ed-449f-b5ec-bab5d34b88ac.png)

<h3> 4) Async-blocking </h3>

- Async-blocking의 경우는 사실 잘 마주하기 쉽지 않다.
- A함수는 B함수의 리턴 값에 신경쓰지 않고, 콜백함수를 보낸다. (<b>비동기</b>)
- 그런데, B함수의 작업에 관심없음에도 불구하고, A함수는 B함숭게ㅔ 제어권을 넘긴다.(<b>블로킹</b>)
- 따라서, A함수는 자신과 관련 없는 B함수의 작업이 끝날 때까지 기다려야 한다.

![image](https://user-images.githubusercontent.com/62228401/233755354-4971d510-d0fe-454c-a0e1-c82243663bed.png)

- Async-blocking의 경우 sync-blocking과 성능의 차이가 비슷하여 사용하는 경우는 거의 없다.
