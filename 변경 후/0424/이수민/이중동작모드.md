# OS 이중 동작 모드란?
- 운영체제를 보호하기 위한 기법이다.
- 사용자와 운영체제는 시스템을 공유하는데 사용자에게 제한을 두지 않으면 사용자가 메모리 내의 주요 OS 자원을 망가뜨릴 위험이 생기게 된다.
- 이런 상황에서 보호하기 위해 있는 장치가 "이중 동작 모드" 이다.

- 사용자가 접근할 수 없는 커널 모드
- 사용자가 접근할 수 있는 사용자 모드

</br>

## 이중 동작 모드 구조
![image](https://user-images.githubusercontent.com/58407737/233981344-15329fa2-79d4-49a7-afef-97d092278b23.png) </br>

### 커널 모드 (= 슈퍼바이저 모드, 시스템 모드, 특권 모드)
- OS를 위한 동작
### 사용자 모드
- 사용자를 위한 동작

</br>

- 사용자 모드에서 특권 명령을 실행하려면 시스템은 이 명령을 불법으로 간주하고 수행하지 못하게 한다.
- 특권 명령: 인터럽트 핸들링, 사용자 모드에서 커널 모드로 전환, 입출력 관리 등

</br>

### 흐름
- 사용자가 사용하는 응용 프로그램은 사용자 모드에서 작동이 되어지게 되는데, 해당 프로그램이 OS에게 시스템 사용을 요청하게 되면 커널 모드로 바꾸어서 요청된 시스템을 실행한 뒤에, 다시 사용자 모드로 전환한다.
- 두 모드를 구분하기 위해 모트 비트를 플래그로 사용한다.
- 하나의 비트는 컴퓨터 하드웨어(CPU 내부 레지스터)에 추가되어있다.
- 커널 모드 일 때 비트값 0, 사용자 모드일 때 비트값 1
- 이 비트를 이용해 OS 체제를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다.

</br>

- 시스템 부트 시 하드웨어는 커널 모드에서 시작한다. 이어 운영체제가 적재되고, 사용자 모드에서 사용자 프로세스가 시작된다.
- 트랩이나 인터럽트가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다. (즉, 모드 비트를 0으로 변경)
- 그러므로 OS가 컴퓨터 제어를 얻을 때마다 항상 커널 모드에 있게 된다.
- 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드(모트 비트 1로 설정)로 전환한다.


</br>

## 이중 동작 모드의 중요성
- OS 내부에는 나쁜 영향을 끼칠 수 있는 일부 명령들을 특권 명령으로 지정함으로써, OS 자신과 사용자에게 시스템적 보호를 제공한다.
- 하드웨어는 특권 명령이 커널 모드에서만 실행되도록 허용한다.
- 사용자 모드에서 특권 명령을 실행하려고 시도하면, 하드웨어는 이를 실행하지 않고, 불법적인 멸령으로 간주해 OS로 트랩을 건다.
- 커널 모드로 전환하는 명령어가 특권 명령의 한 예이다.
- 또 다른 예는 입출력 제어, 타이머 관리, 인터럽트 관리를 위한 명령어들이 있다.

- 이중 동작 모드가 없다면, 잘못된 사용자 프로그램이 데이터를 OS 부분에 덮어 기록함으로써 OS를 지워버릴 수 있고, 또한 여러 프로그램이 동시에 한 장치에 기록할 수 있으며, 그 경우 예상치 못한 결과가 발생한다.

- 사용자 프로그램이 불법적인 명령을 실행하려 하거나 사용자 주소 공간이 아닌 메모리에 접근을 시도하는 등과 같이 오류가 발생하면 하드웨어는 OS로 트랩을 발생시킨다.
- 트랩은 인터럽트처럼 인터럽트 백터를 통해 제어를 운영체제에 넘긴다.
- 프로그램 오류가 발생할 때마다 운영체제는 프로그램을 비정상적으로 종료 시킨다.
- 이때, 적절한 오류 메시지가 주어지며, 프로그램의 메모리가 덤프된다.
- 메모리 덤프는 사용자나 프로그래머가 이를 조사하고, 프로그램을 수정하여 다시 실행 시킬 수 있도록 일반적으로 파일에 기록된다.

</br>

## 모드 전환
### 컴퓨터가 켜지고 사용자 애플리케이션을 실행할 때 어떻게 모드가 변하는지?

### 1. 컴퓨터 부팅 과정 - 커널 모드
### 2. 앱 실행 과정 - 커널 모드
### 3. 앱 실행 중 - 사용자 모드
### 4. 인터럽트 발생 후 처리 과정 - 커널 모드
### 5. 인터럽트 처리 후 - 사용자 모드

- 사용자가 하드웨어 자원에 접근하는 것은 위험하다. 이런 접근은 모두 커널 모드로 OS에서 처리한다. 프로그램에서 SW 인터럽트를 발생 시켜 OS에 위임한다. 

</br>

### 4번 인터럽트 발생 후 처리 과정은?

### (1) 하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)
### (2) CPU에서 모드 플래그를 커널 모드 값으로 설정
### (3) 해당 하드웨어 ISR(Interrupt Service Routine - 해당 인터럽트를 어떻게 처리할지 적힌 코드)으로 이동 (커널 모드)
### (4) 인터럽트 처리 (커널 모드)
### (5) 인터럽트 처리 완료 후 CPU 모드 플래그를 다시 사용자 모드 값으로 설정
### (6) 원래 애플리케이션 위치로 복귀 (사용자 모드)

- 애플리케이션이 실행할 때 위와 같은 모드 변경이 반복적으로 일어난다.

</br>


## 하드웨어 보호
- 이중 모드는 OS의 보호 기능 중 하나이다.
- OS가 보호하는 하드웨어는 입출력 장치, 메모리, CPU가 있다.

</br>

### 입출력 장치 보호
- I/O 장치를 통해 여러 정보가 컴퓨터로 입력되어, 외부 장치로 출력이 된다. I/O 장치를 이용하게 되면 발생하는 문제점이 몇개 있다.

(1) 여러 입출력 장치의 사용으로 인한 혼선이 발생한다. </br>
(2) 사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력 한다. </br>

- 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자 데이터에 접근하려는 경우, 막아야한다.
- 그래서 in, out 과같은 입출력 명령을 특권 명령으로 설정한다.
- 사용자 앱에서 입출력을 사용할 때 OS를 통해서 수행해야하는데 사용되는 것이 SW 인터럽트이다.
- 동시에 입출력을 사용할 경우 ISR로 순서를 정해 혼선을 막아준다.
- 사용자가 다른 사용자 데이터 읽을 경우, OS가 해당 데이터에 접근할 수 있는 여부를 판단하여 거부시킬 수 있다.

</br>

### 메모리 보호
- 메모리에는 OS와 여러 사용자 앱이 존재한다.
- 한 앱이 자신에게 할당된 메모리 영역 외의 영역, 즉 OS나 다른 앱의 메모리 영역에 침범하게 되면 위험하다.

![image](https://user-images.githubusercontent.com/58407737/233986471-29acc6bf-d0bd-435a-9879-2d9e22fab939.png) </br>

위 그림의 경우, User1이 OS, User2, User3에 접근하는 것을 막아야한다. </br>
CPU는 address bus를 통해 메모리 주소에 접근하고 address bus에서 User1 프로그램이 실행되는 동안 User1이 할당된 메모리 주소 범위 안의 경우에만 접근할 수 있도록 검사한다. </br>
이때 사용되는 것이 MMU이다. </br>

![image](https://user-images.githubusercontent.com/58407737/233987053-9a891851-06b7-4b9c-b409-871e599a339f.png) </br>


Memory Management Unit(MMU)은 Address bus 중간에 설치된 하드웨어 칩이다. </br>
MMU는 그림처럼 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다. </br>

User1이 수행되는 동안 OS는 이 프로그램의 주소 범위를 MMU에 설정(특권 명령)한다. User1의 시작주소가 1024, 끝 주소가 4048인 경우 base는 1024, limit는 4048이 된다. </br>
User1이 수행될 동안 이 범위 안 주소값만 address bus를 통과하고 그 밖의 주소 값이 들어오게 되면 MMU에서 내부 인터럽트를 발생 시켜 CPU에 신호를 보낸다. </br>
CPU는 관련된 ISR로 이동하여 해당 프로그램을 강제 종료시킨다. 이런 잘못된 메모리 접근을 Segment violation이라고 한다. </br>


### CPU 보호
- 한 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못하기 때문에 CPU 독점은 방지해야 한다.
```while(true)  
{  
  // do something 
}  
```
 </br>
 
 위와 같은 코드는 무한 반복을 일으켜 CPU를 독점하게 된다. 이를 해결하기 위해선 타이머를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킬 수 있다.  </br>
 인터럽트가 발생하면 운영체제 내의 ISR로 이동하고 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.  </br>
 
  </br>




