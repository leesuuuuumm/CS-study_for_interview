<h1> 가상 메모리(Virtual Memory) </h1>

- 물리적인 메모리 공간의 한계를 극복하기 위해 물리적인 메모리 공간만큼의 메모리 공간을 학보하여 메모리 용량을 늘리는 기술
- 가상 메모리는 하드 디스크의 용량을 떼서 사용하는 기술인데, 페이지(Page) 단위로 하드디스크-램을 swap하면서 이루어진다.

<h3> 가상 메모리는 왜 태어났는가? </h3>

![image](https://user-images.githubusercontent.com/62228401/233940416-10aa933a-c1bf-4daf-b786-184a5e8debac.png)

- 예전 도스시절 하나의 프로그램만 실행시키던 그 때 프로그램이 메모리를 사용하다가 프로그램이 죽는 경우 이 메모리를 회수시킬 방법이 없어 결국 OS를 재시작하게 되는 문제로부터 시작되었다.
- 즉, 프로세스가 운영전체(시스템) 전체에 문제가 나는 것을 막기 위해
- 프로세스의 사용 공간을 가상 세계로 범위를 제한 시켜 애플리케이션이 죽어도 OS는 살아남는다. (시스템의 안정성을 위해)
- <b> 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능 </b> 하도록 하는 기법이다.
- 가상 메모리 기법을 통해 사용자 프로그램이 물리적 메모리보다 커져도 실행이 가능하도록 한다.
- 가상 메모리는 실제의 물리 메모리 개념과 사용자 관점의 논리 메모리를 분리한 것이다.
- 그래서 사용자가 메모리 크기에 관련한 문제를 염려하지 않아도 된다.
- 운영체제는 가상 메모리 기법을 통해 프로그램의 논리적 주소 영역에서 필요한 부분만 물리적 메모리에 적재하고, 직접적으로 필요하지 않은 메모리 공간은 디스크에 저장하게 된다.
- 프로그램을 동작하기 위해서는 실제 프로그램 파일에 메모리에 할당되어 프로세스가 처리된다.
- 하지만 <b> 실제 메모리의 용량은 비싸고 제한적이다. </b>
- 그래서 <b> 보조 기억장치(HHD, SSD 등)로 메모리 확장을 하여 사용 </b>하게 된다.
- 메모리 용량 이상의 주소 할당 요청을 하면, 보통 덜 사용하고 있는 프로그램은 보조 기억장치로 옮겨진다. (Swap)
- 여유 공간을 확보한 메모리 주소에 새 할당 요청에 처리한다.

<h3> 장점 </h3>

1. 큰 가상의 메모리 공간을 확보할 수 있다.
2. 더 효율적인 메모리 사용이 가능해진다.
3. 더 나은 멀티 프로그래밍을 사용할 수 있게 된다.
4. <b> OS가 프로그램에게 가상 메모리 영역을 할당하기 때문에 프로그램이 뻗어도 OS가 해당 프로그램의 주소 위치를 알기 때문에 자원을 회수할 수 있어 메모리의 낭비가 없고, 프로그램이 죽어도 OS에 영향이 없다. </b>
5. <b> 보조 기억장치 공간을 사용하여 메인 메모리(RAM) 크기보다 더 큰 공간 사용</b>이 가능하다. (확장성)
6. 물리 주소를 연속적인 주소로 바꿔준다. ( 물리적으로 별개의 메모리면 주소가 비연속적 )

<h3> 단점 </h3>

1. 싱글 페이지 관리 기술일 때보다 테이블의 수와 여러 페이지들을 핸들링하기 위한 오버헤드가 증가한다. (한 마디로 신경써야할게 많아졌다.)
2. 작업의 주소 공간에 대한 명시적 제한이 없다. ( 이렇게 되면 컨트롤하기 어려워진다.)

<h1> 요구 페이징(demand paging) </h1>

- <b> 필요한 부분만 물리적 메모리에 page 단위로 적재하는 방법을 요구 페이징 </b> 이라고 한다.
- 요구 페이징 기법에서는 특정 page에 대해 cpu 요청이 들어온 후에 해당 page를 메모리에 적재합니다.
- 그렇기 때문에, 당장 필요한 page만을 메모리에 적재하기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리 적재하는 입출력 오버헤드도 감소하는 장점이 있습니다.
- 요구 페이징 기법에서는 <b> 유효/무효 비트(valid/invalid bit) </b> 를 두어 각 page가 메모리에 존재하는지 표시하게 됩니다.

<b> 유효 /무효 비트 : 해당 비트가 유효하면 메모리에 있음을 의미하고, 무효하면 메모리에 없음을 의미합니다. </b>

<h1> Page fault </h1>

- CPU가 무효 비트로 표시된 page에 액세스 하는 상황을 page fault라고 한다.

<h3> 페이지 부재를 처리하는 과정 </h3>

- CPU가 특정 페이지를 접근하여 페이지 테이블에서 무효 상태인지 아닌지 확인한다.
- 페이지가 무효 상태일 경우 MMU에서 Page fault trap이 발생한다.
- 디스크에서 해당 페이지를 빈 프레임에 적재하고 페이지 테이블을 업데이트 한다. ( 무효 -> 유효 )
- 트랩에 의해 중단되었던 명령을 다시 수행한다.

<b> MMU : 가상 주소를 물리 메모리 주소로 변환해주는 하드웨어 장치 </b>

<h1> Page 교체 알고리즘(replacement algorithm) </h1>

- page fault가 발생하면, 요청된 page를 디스크에서 메모리로 가져옵니다.
- 이 때, 물리적 메모리 공간이 부족한 상황이 발생할 수 있다.
- 이럴 때 메모리에 올라와 있는 page를 디스크로 옮겨서 메모리 공간을 확보해야 한다.
- 이를 페이지 교체라고 하고, 어떤 page를 교체할지 결정하는 방법은 Page 교체 알고리즘에 따라 달라진다.
- 이 교체 알고리즘은 최대한 page fault가 적게 일어나도록 도와줘야 합니다.
- 그래서 앞으로 사용될 일이 적은 page를 선택하여 교체하는 것이 성능을 향상시킬 수 있다.

- OPT(Optimal)
  - 앞으로 가장 오랫동안 사용하지 않을 page를 찾아 교체한다.
  - 하지만 실제로 구현하기 거의 불간으한 알고리즘이다.
- FIFO(First In First Out)
  - 메모리에 올라온지 가장 오래된 page를 교체하는 알고리즘
- LRU(Least Recently Used)
  - 가장 오랫동안 사용하지 않은 page를 교체하는 알고리즘
- LFU(Least Frequently Used)
  - 가장 참조횟수가 적은 page를 교체하는 알고리즘
