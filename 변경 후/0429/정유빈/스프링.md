<h1> 프레임워크와 라이브러리 차이 </h1>

<h3> 프레임워크 </h3>

- 제어의 주체가 개발자가 아닌 프레임워크이고, 그 안의 여러 가지 기능들을 가져다 사용하는 방식
- 만약 수정해야 할 때는 도구들을 사용해서 수정 및 추가가 가능하다.
- 개발에 필요한 구조를 이미 코드로 만들어 놓았기 때문에, 실력이 부족한 개발자라 하더라도 반쯤 완성한 상태에서 필요한 부분을 조립하는 형태의 개발이 가능하다.
- 회사 입장에서는 프레임워크를 사용하면 <b> 일정한 품질 </b> 이 보장되는 결과물을 얻을 수 있다.
- 개발자 입장에서는 완성된 구조에 자신이 맡은 코드를 개발해서 넣기 때문에 <b> 개발 시간을 단축 </b>할 수 있다.

<h3> 라이브러리 </h3>

- 주체가 개발자이며, 핵심 로직에서 필요한 부분들만 가져다 사용하는 방식

<h1> 프레임워크 중에서 왜 자바 스프링인가? </h1>

- 스프링은 여러 프레임워크 중 자바(Java)를 기반으로 하는 프레임워크이다.
- 우선, 자바 스프링의 특징부터 알아보자.
- 이러한 특징들 덕분에 프로그래머는 더욱 편하게 서버 개발이 가능하다.

<h3> 1. POJO 기반의 구성(Plain Old Java Object) </h3>

- 코드를 개발할 때, 개발자가 특정한 라이브러리나 컨테이너의 기술에 종속적이지 않음을 의미한다.
- Java 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에서 사용할 수 있다.
- 덕분에, 자유롭게 객체 지향적 설계를 구현할 수 있따.
- 즉, 개발자는 가장 일반적인 형태로 코드를 작성하고 실행하기 때문에, 높은 생산성과 유연한 테스트를 할 수 있다는 장점을 가지게 된다.

<h3> 2. DI(Dependency Injection, 의존성 주입)을 통한 객체 관계 구성 </h3>

<b> "DI는 객체 지향 프로그래밍의 강력한 지원군이다" </b>

- 의존성 주입은 제어의 역전이 일어나는 것을 전제로, 스프링 내부의 객체들 간의 관계를 관리할 때 사용한다.
- 의존성 주입은 특정 개체에 필요한 객체를 외부에서 결정하여 연결시키는 것을 말한다.
- 자바에서는 인터페이스를 사용하여 의존적인 관계를 처리한다.
- 메소드나 객체(bean)의 호출 작업은 제어의 역전을 통해 외부에서 이루어진다.
- 제어의 역행을 전제 조건으로 의존성 주입이 일어난다.
- 의존성을 가진 객체에 대해 스프링에서 의존성 주입이 발생하도록 한다.
- 의존성 주입 특징으로 인해 개발자가 POJO 개발이 가능하게 된다.

- 실무에서는 주로 정형화된 컨트롤러, 서비스, 레포지토리 같은 코드는 컴포넌트 스캔을 사용한다.
- 그리고 정형화 되지 않았거나 상황에 따라 구현 클래스를 변경해야 하면 설정에 따라 스프링 빈으로 등록한다.

<b> 컴포넌트 스캔과 자동 의존관계 설정 </b>

- 예를 들어, MemberController 생성자에 @Autowired를 붙임으로써, 스프링은 스프링이 저장하고 있는 memberService 객체를 컨트롤러가 생성될 대 가져와 준다.
- 즉, 생성자에 @Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어줍니다.
- 이렇게 객체 의존관계를 외부에서 넣어주는 것을 의존성 주입(DI)라 한다.
- 스프링이 시작될 때, @Controller, @Service, @Repository와 같은 컴포넌트들을 스캔하고 스프링에 빈으로 등록한다.
- 기본적으로 @Component가 있으면 스프링 빈으로 자동 등록 되며, 위의 세 어노테이션도 @Component를 포함하고 있기에 스프링 빈으로 자동 등록된다.
- 스프링 빈으로 등록된다면, "스프링 컨텡너에서 빈이 관리된다"라고 말한다.
- 이후 @Autowired 어노테이션으로 등록된 빈들의 의존 관계를 연결한다.

![image](https://user-images.githubusercontent.com/62228401/235031974-d7e26fbf-3152-417a-a63b-e687b6472bca.png)

- 예를 들어, MemberController의 생성자에 @Autowired를 붙임으로써, 스프링은 스프링이 저장하고 있는 memberService 객체를 컨트롤러가 생성될 때 가져와 준다.
- 즉, 생성자에 @Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다.
- 이렇게 객체 의존관계를 외부에서 넣어주는 것을 의존성 주입(DI)라고 한다.

<b> 의존성 주입 방법 </b>

1. 필드 주입
2. setter 주입
3. 생성자 주입

<b> 생성자 주입 권장 이유 </b>

1. 순환 의존성 확인 : 필드 주입으로는 순환 의존성을 파악하기 어렵다. 생성자 주입을 하게 되면 서버 기동 시 순환 의존성을 가지는 요소들을 파악할 수 있게 에러메시지를 표시하면서 서버가 가동되지 않는다.
2. 불변성 : 필드 주입은 final을 선언할 수 없지만 생성자 주입은 final을 선언함으로써 객체가 변하지 않도록 방지해준다.
3. 단일 책임 원칙 위반 확인

<b> @Autowired 어노테이션을 이용한 의존성 주입 </b>

- 객체 연결을 할 때 사용. 
- 필드 혹은 생성자에 사용하면 컨트롤러, 서비스 등이 생성될 때 스프링빈에 등록되어 있는 객체를 가져다 넣어준다.


1. 필드 주입 방법

```java
 public class ExampleCase{
      @Autowired
      private ChocolateService chocolateService;
      
      @Autowired
      private DrinkService drinkService
```

2. 생성자 주입 방법(권장)

```java
public class ExampleCase{
      private final ChocolateService chocolateService;
      private final DrinkService drinkService;
      
      @Autowired
      public ExampleCae(ChocolateService chocolateService, DrinkService drinkService){
           this.chocolateService = chocolateService;
           this.drinkService = drinkService;
       }
```

@RequriredArgsConstructor 어노테이션을 이용한 의존성 주입

```java
@RequiredrgsConstructor //final로 선언된 멤버 변수를 자동으로 생성한다.
@RestoController // JSON으로 데이터를 주고받음을 선언한다.
public class ExampleCase{
    
    private final ChocolateService chocolateService;
    private final DrinkService drinkService;
```
https://joychae.tistory.com/27
