<h1> 교착상태란? </h1>

- 교착상태(Dead Lock)은 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미한다.

<h1> 교착상태 발생 조건 </h1>

- 주로 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황에서 발생한다.
- 교착 상태가 발생하기 위해서는 다음의 네 가지 조건이 충족되어야 하는데, 이 네가지 조건 중 하나라도 충족되지 않으면 교착 상태가 발생하지 않는다.

<h3> 상호 배제(Mutual Exclusion) </h3>

- 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
- 상호 배제 기법에는 뮤텍스, 세마포어 등이 있다.

<h3> 점유와 대기(Hold and Wait) </h3>

- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

<h3> 비선점(No-preemption) </h3>

- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

<h3> 환경 대기(Circular Wait) </h3>

- 서로 다른 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

<h1> 교착상태 해결 방안 </h1>

<h3> 예방(Prevention) </h3>

- 교착 상태가 발생하지 않도록 사전에 시스템을 제어하는 방법으로 교착 상태 발생의 4가지 조건 중에서 어느 하나를 제거한다. 단, 자원 낭비가 가장 심한 해결 방법이다.

-  <b> 상호 배제(Mutual Exclusion) 부정 </b>
    - 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.

- <b> 점유 및 대기(Hold and Wait) 부정 </b>
    - 프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원을 점유되지 않은 상태에서만 자원을 요구한다.

- <b> 비선점(Non-preemption) 부정 </b>
    - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다린다.

- <b> 환형 대기(Circular Wait) 부정 </b>
    - 자원을 선형 순서로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한 쪽 방향으로만 자원을 요구하도록 한다.

<h1> 세마포어(Semaphore)와 뮤텍스(Mutex) 차이 </h1>

- 동시성 프로그래밍의 가장 큰 숙제는 "공유자원 관리"일 것이다.
- 공유자원을 안전하게 관리하기 위해서는 <b> 상호배제(Mutual Exclusion) </b>을 달성하는 기법이 필요하다.
- 프로세스 간 메시지를 전송하거나, 공유 메모리를 통해 공유 자원에 여러 개의 프로세스가 동시에 접근하면 Critical Section(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다.
- 이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야 한다.
- 동기화 도구에는 뮤텍스(Mutex)와 세마포어(Semaphore)가 있다.
- 이들은 모두 공유된 자원의 데이터를 스레드/프로세스가 접근하는 것을 막는 역할을 한다.

<h1> Mutex(뮤텍스) </h1>

- 공유된 자워늬 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌(동기화 대상이 하나)
- 임계구역(Critical Section)을 가진 스레드들의 실행 시간(Running Time)이 서로 겹치지 않고 각각 단독으로 실행(상호 배제_Mutual Exclusion)이 되도록 하는 기술입니다.)

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/972ade03-51a0-4576-aa7c-5852738f4e83)

- 한 프로세스에 의해 공유될 수 있는 Key를 기반으로 한 상호배제 기법이고, Key에 해당하는 어떤 객체(Object)가 있으며, 이 객체를 소유한 스레드/프로세스만이 공유자원에 접근할 수 있습니다.
- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 <b> 동기화(Synchronization) 또는 락(Lock) </b> 을 사용함으로써 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없습니다.


<br/>
- 뮤텍스는 화장실이 하나 밖에 없는 식당과 비슷합니다.

- 화장실을 가기 위해서는 카운터에서 열쇠를 받아 가야하며 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있다고 가정합니다.

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/623efac7-658c-4df5-a720-20c041bee31a)

- 카운터에 열쇠가 없기 때문에 화장실에 사람이 있다는 뜻이며 화장실을 사용할 수 없습니다.
- 여자가 나올 때까지 기다려야 합니다.

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/21b587be-7470-458a-9af4-cd55c50b17dc)

- 곧이어 다른 사람도 화장실에 가려고 카운터에 대기하고 있습니다.
- 앞 사람이 화장실에서 나와 카운터에 키를 돌려놓았습니다.
- 이제 기다리던 사람들 중 맨 앞에 있던 사람이 키를 받아 화장실을 갈 수 있습니다.
 
<br />

- 이것이 뮤텍스가 동작하는 방식입니다.
- 화장실을 이용하는 사람은 프로세스 혹은 쓰레드이며 화장실은 공유 자원, 화장실 키는 공유 자원에 접근하기 위해 필요한 어떤 오브젝트입니다. 
- 즉, 뮤텍스는 Key에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드, 프로세스) 만이 공유자원에 접근할 수 있습니다.

<h1> Semaphore 세마 포어 </h1>

- 공유된 자원의 데이터 혹은 임계 영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌(동기화 대상이 하나 이상)

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/b879670b-8464-467f-b819-62ddcb5f4956)

- 사용하고 있는 스레드/프로세스 수를 공통으로 관리하는 하나의 값을 사용해 상호 배제를 달성합니다.
- 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자만큼 접근할 수 있으며, 각 프로세스는 세마포어의 값을 확인하고 변경할 수 있습니다.
- 자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용하고, 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면, 재시도 전에 일정 시간 대기해야 합니다.
- 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 사용하게 됩니다. 

<br />

- 사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 사용해 상호배제를 달성합니다.
- 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있으며, 각 프로세스는 세마포어의 값을 확인하고 변경할 수 있습니다.
- 자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용하고 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면, 재시도 전에 일정 시간 대기해야 합니다.
- 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 사용하게 됩니다.

<br />

- 세마 포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑입니다.
- 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있고 화장실 입구에는 현재 화장실의 빈 칸의 개수를 보여주는 전광판이 있다고 가정합니다.

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/2c863193-7d8e-44c0-a9ee-6d3cef58c8bb)

- 만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈칸이 1개 이상이라면 빈 칸의 개수를 하나 뺀 다음에 화장실로 입장해야 하며 나올 때 빈캄의 개수를 하나 더해줍니다.

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/92cba10d-136a-4cd0-a833-8730a6d7864a)

- 모든 칸에 사람이 들어갔을 경우 빈칸의 개수는 0이며 이 때 회장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1 혹은 양수로 바뀔 때까지 기다려야 합니다.
- 이처럼 세마포어는 공통으로 관리하는 하나의 값을 사용해 상호 배제를 달성하빈다. 
- 세마포어도 아까와 똑같이 화장실이 공유 자원이며 사람들이 쓰레드, 프로세스이다.
- 그리고 화장실의 빈칸의 개수는 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 개수를 나타냅니다.

<h3> 차이점 </h3>

- 가장 큰 차이점은 동기화 대상의 개수 즉, 화장실의 개수이다.

- Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용한다.
- Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
    - Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 Mutex를 해제할 수 있다.
- 반면, Semaphore는 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.
- Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up됩니다.
