<h1> Race Condition </h1>

- 2개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 실행 결과가 같지 않고 달라지는 상황
-  race란 2개의 스레드가 하나의 자원을 놓고 서로 사용하려는 경쟁하는 상황을 말함
-  경쟁 프로세스의 경우, Mutual exclusion, Deadlock, Starvation 3가지 제어 문제에 직면한다.

<h3> Mutual exclusion </h3>

- Race condiiton을 막기 위해서는 2개 이상의 프로세스가 공용 데이터에 동시에 접근을 하는 것을 막아야 한다.
- 즉, 한 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막거나, 다른 프로세스가 그 자원을 사용하지 못하도록 막으면 이 문제를 피할 수 있다.
- 이것을 상호 배제(mutual exclusion)이라고 부른다.

<h3> Deadlock </h3>

- 프로세스가 자원을 얻지 못해 다음 처리를 못 하는 상태로, "교착 상태"라고 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

![image](https://github.com/youbeen2798/CS-study_for_interview/assets/62228401/0758a0fd-8f86-48c5-8d30-ca67d7c62a51)
- t1에 P1이 리소스 A를 얻고, P2가 리소스 B를 얻었다면 t2 때 P1은 리소스 B를, P2는 리소스 A를 기다리게 된다.
- 하지만 서로 원하는 리소스가 상대방에게 할당되어 있기 때문에 이 두 프로세스는 무한정 기다리게 되는 상태를 Deadlock상태라고 한다.

<h3> Starvation </h3>

- 프로세스들이 더 이상 진행을 하지 못하고 영구적으로 블록되어 있는 상태로, 시스템 자원에 대한 경쟁 도중에 발생할 수 있고, 프로세스 간의 통신 과정에도 발생할 수 있는 문제
- 2개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리기 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태가 되게 된다.

<h1> 예방할 수 있는 방법 </h1>

- race condition을 예방할 수 있는 방법으로 Semaphore(세마포어)와 Mutex(뮤텍스)가 있다.

<h3> Semaphore(세마포어) </h3>

- 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것이다.

<h3> Mutex(뮤텍스) </h3>

- 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법이다.
- 즉, Critical Section을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술
- 다중 프로세스들이 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking을 사용하는데, 다시 말해서 상호배제를 함으로써 두 쓰레드가 동시에 사용할 수 없다는 뜻이다.

<h3> 1. 데커(Dekker) 알고리즘 </h3>

- 데커의 알고리즘에서는 각 프로세스는 플래그를 설정할 수 있고, 다른 프로세스를 확인한 후 플러그를 재설정할 수 도 있다. 
- 프로세스가 임계 영역에 진입하고 싶으면 플래그를 설정하고 차례를 기다린다.
- 즉, 임계 영역에 다른 프로세스가 이미 있으면 해당 프로세스를 종료할 때까지 while문에서 순환한다.
- 그리고 프로세스간의 순서를 나타내는 turn 변수를 사용한다.

```
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if(turn == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            while(turn == j); // turn이 j에서 변경될 때까지 대기
            flag[i] = true; // j turn이 끝나면 다시 진입 시도
        }
    }
}

// ------- 임계 구역 ---------

turn = j; // 임계 구역 사용 끝나면 turn을 넘김
flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```
- 특별한 하드웨어 명령문이 필요 없다.
- 임계 영역 바깥에서 수행 중인 프로세스가 다른 프로세스들이 임계 영역에 들어가려는 것을 막지 않는다.
- 임계 영역에 들어가기를 원하는 프로세서를 무한정 기다리게 하지 않는다.

<h3> 2. 피터슨 알고리즘 </h3>

- 데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있다.
```
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
    }
}

// ------- 임계 구역 ---------

flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```
<h3> 2. 제과점(Bakery) 알고리즘 </h3>

- 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘이다.
- 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다. 

```
while(true) {
    
    isReady[i] = true; // 번호표 받을 준비
    number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
    isReady[i] = false; // 번호표 수령 완료
    
    for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
        while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
        while(number[j] && number[j] < number[i] && j < i);
        
        // 프로세스 j가 번호표 가지고 있어야 함
        // 프로세스 j의 번호표 < 프로세스 i의 번호표
    }
}

// ------- 임계 구역 ---------

number[i] = 0; // 임계 구역 사용 종료
```












